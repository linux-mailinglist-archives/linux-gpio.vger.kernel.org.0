Return-Path: <linux-gpio-owner@vger.kernel.org>
X-Original-To: lists+linux-gpio@lfdr.de
Delivered-To: lists+linux-gpio@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 5D18F55A9B6
	for <lists+linux-gpio@lfdr.de>; Sat, 25 Jun 2022 14:14:35 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232809AbiFYMIi (ORCPT <rfc822;lists+linux-gpio@lfdr.de>);
        Sat, 25 Jun 2022 08:08:38 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:46896 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S232170AbiFYMIi (ORCPT
        <rfc822;linux-gpio@vger.kernel.org>); Sat, 25 Jun 2022 08:08:38 -0400
Received: from ams.source.kernel.org (ams.source.kernel.org [145.40.68.75])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B5B232BB13;
        Sat, 25 Jun 2022 05:08:35 -0700 (PDT)
Received: from smtp.kernel.org (relay.kernel.org [52.25.139.140])
        (using TLSv1.2 with cipher ECDHE-RSA-AES256-GCM-SHA384 (256/256 bits))
        (No client certificate requested)
        by ams.source.kernel.org (Postfix) with ESMTPS id 69751B807E5;
        Sat, 25 Jun 2022 12:08:34 +0000 (UTC)
Received: by smtp.kernel.org (Postfix) with ESMTPSA id 02FC6C3411C;
        Sat, 25 Jun 2022 12:08:33 +0000 (UTC)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/simple; d=kernel.org;
        s=k20201202; t=1656158913;
        bh=veiT+bMUWyUEWmup47z/D8oPLnmA4xLJ1PTrTZlDMjI=;
        h=Date:From:To:Cc:Subject:In-Reply-To:References:From;
        b=eGnBk1IoovvYB98tc+QSKAtfs/XrLk2tGbL96bEAi7vPBeW91kDHZxEUCcKPO6vr3
         dJoRoeSNz0eO+zLj+Zh1n1YsHmy0YPxcCot8c2i4shcvHGu0ITKsZ8I+Vt/CRK1Vl/
         YxYs7bO5moVbfqFO6/VRiIWtrKfH61NYBd1yHqS0jB2d8U4MOMaB3X/BEJbhnibiFc
         YSisD9M7cXTWfPMv36P//LQnQuLII3cAoEqpQCwRA93EOmRyiyosFSdjQM+JEIymjp
         cWgUMQFmIKHZTNB1ZX1GL8KFst3ilKfQ86fuoDTVv2EOwShDj/lugQ5avom8rKeF+h
         FWjk3jxwaS9Tg==
Received: from sofa.misterjones.org ([185.219.108.64] helo=why.misterjones.org)
        by disco-boy.misterjones.org with esmtpsa  (TLS1.3) tls TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384
        (Exim 4.95)
        (envelope-from <maz@kernel.org>)
        id 1o54aU-0033vB-Jn;
        Sat, 25 Jun 2022 13:08:30 +0100
Date:   Sat, 25 Jun 2022 13:08:30 +0100
Message-ID: <87fsjt2bep.wl-maz@kernel.org>
From:   Marc Zyngier <maz@kernel.org>
To:     "Lad, Prabhakar" <prabhakar.csengg@gmail.com>
Cc:     Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com>,
        Geert Uytterhoeven <geert+renesas@glider.be>,
        Thomas Gleixner <tglx@linutronix.de>,
        Rob Herring <robh+dt@kernel.org>,
        Krzysztof Kozlowski <krzysztof.kozlowski+dt@linaro.org>,
        Linus Walleij <linus.walleij@linaro.org>,
        Bartosz Golaszewski <brgl@bgdev.pl>,
        Thierry Reding <thierry.reding@gmail.com>,
        Jonathan Hunter <jonathanh@nvidia.com>,
        Bjorn Andersson <bjorn.andersson@linaro.org>,
        Andy Gross <agross@kernel.org>,
        Philipp Zabel <p.zabel@pengutronix.de>,
        Andy Shevchenko <andy.shevchenko@gmail.com>,
        "open list:GPIO SUBSYSTEM" <linux-gpio@vger.kernel.org>,
        linux-tegra <linux-tegra@vger.kernel.org>,
        linux-arm-msm <linux-arm-msm@vger.kernel.org>,
        "open list:OPEN FIRMWARE AND FLATTENED DEVICE TREE BINDINGS" 
        <devicetree@vger.kernel.org>, LKML <linux-kernel@vger.kernel.org>,
        Linux-Renesas <linux-renesas-soc@vger.kernel.org>,
        Phil Edworthy <phil.edworthy@renesas.com>,
        Biju Das <biju.das.jz@bp.renesas.com>
Subject: Re: [PATCH v5 2/5] irqchip: Add RZ/G2L IA55 Interrupt Controller driver
In-Reply-To: <CA+V-a8veE6-4C+9kyTNxqsf0jB5xCGhcHncTSM3ejDzBAfz=Bw@mail.gmail.com>
References: <20220523174238.28942-1-prabhakar.mahadev-lad.rj@bp.renesas.com>
        <20220523174238.28942-3-prabhakar.mahadev-lad.rj@bp.renesas.com>
        <871qvdf5tb.wl-maz@kernel.org>
        <CA+V-a8veE6-4C+9kyTNxqsf0jB5xCGhcHncTSM3ejDzBAfz=Bw@mail.gmail.com>
User-Agent: Wanderlust/2.15.9 (Almost Unreal) SEMI-EPG/1.14.7 (Harue)
 FLIM-LB/1.14.9 (=?UTF-8?B?R29qxY0=?=) APEL-LB/10.8 EasyPG/1.0.0 Emacs/27.1
 (x86_64-pc-linux-gnu) MULE/6.0 (HANACHIRUSATO)
MIME-Version: 1.0 (generated by SEMI-EPG 1.14.7 - "Harue")
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: quoted-printable
X-SA-Exim-Connect-IP: 185.219.108.64
X-SA-Exim-Rcpt-To: prabhakar.csengg@gmail.com, prabhakar.mahadev-lad.rj@bp.renesas.com, geert+renesas@glider.be, tglx@linutronix.de, robh+dt@kernel.org, krzysztof.kozlowski+dt@linaro.org, linus.walleij@linaro.org, brgl@bgdev.pl, thierry.reding@gmail.com, jonathanh@nvidia.com, bjorn.andersson@linaro.org, agross@kernel.org, p.zabel@pengutronix.de, andy.shevchenko@gmail.com, linux-gpio@vger.kernel.org, linux-tegra@vger.kernel.org, linux-arm-msm@vger.kernel.org, devicetree@vger.kernel.org, linux-kernel@vger.kernel.org, linux-renesas-soc@vger.kernel.org, phil.edworthy@renesas.com, biju.das.jz@bp.renesas.com
X-SA-Exim-Mail-From: maz@kernel.org
X-SA-Exim-Scanned: No (on disco-boy.misterjones.org); SAEximRunCond expanded to false
X-Spam-Status: No, score=-7.7 required=5.0 tests=BAYES_00,DKIMWL_WL_HIGH,
        DKIM_SIGNED,DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_HI,
        SPF_HELO_NONE,SPF_PASS,T_SCC_BODY_TEXT_LINE autolearn=ham
        autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-gpio.vger.kernel.org>
X-Mailing-List: linux-gpio@vger.kernel.org

On Sat, 25 Jun 2022 11:54:44 +0100,
"Lad, Prabhakar" <prabhakar.csengg@gmail.com> wrote:
>=20
> Hi Marc,
>=20
> Thank you for the review.
>=20
> On Sat, Jun 25, 2022 at 10:30 AM Marc Zyngier <maz@kernel.org> wrote:
> >
> > On Mon, 23 May 2022 18:42:35 +0100,
> > Lad Prabhakar <prabhakar.mahadev-lad.rj@bp.renesas.com> wrote:
> > >

[...]

> > > +static int rzg2l_irqc_alloc(struct irq_domain *domain, unsigned int =
virq,
> > > +                         unsigned int nr_irqs, void *arg)
> > > +{
> > > +     struct rzg2l_irqc_priv *priv =3D domain->host_data;
> > > +     unsigned long *chip_data =3D NULL;
> >
> > Why the init to NULL?
> >
> Can be dropped.
>=20
> > > +     struct irq_fwspec spec;
> > > +     irq_hw_number_t hwirq;
> > > +     int tint =3D -EINVAL;
> > > +     unsigned int type;
> > > +     unsigned int i;
> > > +     int ret;
> > > +
> > > +     ret =3D irq_domain_translate_twocell(domain, arg, &hwirq, &type=
);
> > > +     if (ret)
> > > +             return ret;
> > > +
> > > +     /*
> > > +      * For TINT interrupts ie where pinctrl driver is child of irqc=
 domain
> > > +      * the hwirq and TINT are encoded in fwspec->param[0].
> > > +      * hwirq for TINT range from 9-40, hwirq is embedded 0-15 bits =
and TINT
> > > +      * from 16-31 bits. TINT from the pinctrl driver needs to be pr=
ogrammed
> > > +      * in IRQC registers to enable a given gpio pin as interrupt.
> > > +      */
> > > +     if (hwirq > IRQC_IRQ_COUNT) {
> > > +             tint =3D TINT_EXTRACT_GPIOINT(hwirq);
> > > +             hwirq =3D TINT_EXTRACT_HWIRQ(hwirq);
> > > +
> > > +             if (hwirq < IRQC_TINT_START)
> > > +                     return -EINVAL;
> > > +     }
> > > +
> > > +     if (hwirq > (IRQC_NUM_IRQ - 1))
> > > +             return -EINVAL;
> > > +
> > > +     chip_data =3D kzalloc(sizeof(*chip_data), GFP_KERNEL);
> >
> > Are we really allocating an unsigned long for something that already
> > fits in something that is pointer-sized?
> >
> I think I received some feedback to use unsigned long.  Let me know
> what you want me to use here.

I think this is just a waste of memory, but I don't really care.

>=20
> > > +     if (!chip_data)
> > > +             return -ENOMEM;
> > > +     *chip_data =3D tint;
> >
> > So here, *chip_data can be set to -EINVAL if hwirq <=3D IRQC_IRQ_COUNT?
> > This can't be right.
> >
> Yes *chip_data can be -EINVAL. IRQC block handles IRQ0-7 and
> GPIOINT0-122. So the -EINVAL here is for IRQ0-7 case were dont
> required the chip data in the call backs hence -EINVAL, Whereas for
> GPIOINT0-122 we need chip_data in the callbacks as this value needs to
> be programmed in the hardware registers.

I can't see anything that checks it (let alone the difference in
types). And if it isn't checked, this means that the allocation is
pointless.

>=20
> > > +
> > > +     ret =3D irq_domain_set_hwirq_and_chip(domain, virq, hwirq, &irq=
c_chip,
> > > +                                         chip_data);
> > > +     if (ret) {
> > > +             kfree(chip_data);
> > > +             return ret;
> > > +     }
> > > +
> > > +     spec.fwnode =3D domain->parent->fwnode;
> > > +     spec.param_count =3D priv->map[hwirq].args_count;
> > > +     for (i =3D 0; i < spec.param_count; i++)
> > > +             spec.param[i] =3D priv->map[hwirq].args[i];
> >
> > Why isn't that simply:
> >
> >         spec =3D priv->map[hwirq];
> >
> spec is of type =E2=80=98struct irq_fwspec=E2=80=99 and map is of type =
=E2=80=98struct of_phandle_args=E2=80=99.
>=20
> > as this really is the interrupt you want to map to?
> >
> Yes.
>=20
> > > +
> > > +     ret =3D irq_domain_alloc_irqs_parent(domain, virq, nr_irqs, &sp=
ec);
> >
> > or even better:
> >
> >         ret =3D irq_domain_alloc_irqs_parent(domain, virq, nr_irqs,
> >                                            &priv->map[hwirq]);
> >
> Does not work as map is of type =E2=80=98struct of_phandle_args=E2=80=99.

Which begs the question: why don't you convert it to an irq_fwspec the
first place and be done with it?

>=20
> > > +     if (ret)
> > > +             kfree(chip_data);
> > > +
> > > +     return ret;
> > > +}
> > > +
> > > +static void rzg2l_irqc_domain_free(struct irq_domain *domain, unsign=
ed int virq,
> > > +                                unsigned int nr_irqs)
> > > +{
> > > +     struct irq_data *d;
> > > +
> > > +     d =3D irq_domain_get_irq_data(domain, virq);
> > > +     if (d)
> > > +             kfree(d->chip_data);
> > > +
> > > +     irq_domain_free_irqs_common(domain, virq, nr_irqs);
> > > +}
> > > +
> > > +static const struct irq_domain_ops rzg2l_irqc_domain_ops =3D {
> > > +     .alloc =3D rzg2l_irqc_alloc,
> > > +     .free =3D rzg2l_irqc_domain_free,
> > > +     .translate =3D irq_domain_translate_twocell,
> > > +};
> > > +
> > > +static int rzg2l_irqc_parse_map(struct rzg2l_irqc_priv *priv,
> > > +                             struct device_node *np)

nit: this function could afford being renamed to something more
correct. It really doesn't map anything, only retrieves the output
interrupts.

> > > +{
> > > +     unsigned int i;
> > > +     int ret;
> > > +
> > > +     for (i =3D 0; i < IRQC_NUM_IRQ; i++) {
> > > +             ret =3D of_irq_parse_one(np, i, &priv->map[i]);

Make map an array of irq_fwspec, and use of_phandle_args_to_fwspec()
for the conversion.

> > > +             if (ret)
> > > +                     return ret;
> > > +     }
> > > +
> > > +     return 0;
> > > +}
> > > +
> > > +static int rzg2l_irqc_init(struct device_node *node, struct device_n=
ode *parent)
> > > +{
> > > +     struct irq_domain *irq_domain, *parent_domain;
> > > +     struct platform_device *pdev;
> > > +     struct reset_control *resetn;
> > > +     struct rzg2l_irqc_priv *priv;
> > > +     int ret;
> > > +
> > > +     pdev =3D of_find_device_by_node(node);
> > > +     if (!pdev)
> > > +             return -ENODEV;
> > > +
> > > +     parent_domain =3D irq_find_host(parent);
> > > +     if (!parent_domain) {
> > > +             dev_err(&pdev->dev, "cannot find parent domain\n");
> > > +             return -ENODEV;
> > > +     }
> > > +
> > > +     priv =3D devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
> > > +     if (!priv)
> > > +             return -ENOMEM;
> > > +
> > > +     priv->base =3D devm_of_iomap(&pdev->dev, pdev->dev.of_node, 0, =
NULL);
> > > +     if (IS_ERR(priv->base))
> > > +             return PTR_ERR(priv->base);
> > > +
> > > +     ret =3D rzg2l_irqc_parse_map(priv, node);
> > > +     if (ret) {
> > > +             dev_err(&pdev->dev, "cannot parse interrupts: %d\n", re=
t);
> > > +             return ret;
> > > +     }
> > > +
> > > +     resetn =3D devm_reset_control_get_exclusive_by_index(&pdev->dev=
, 0);
> > > +     if (IS_ERR(resetn))
> > > +             return IS_ERR(resetn);
> > > +
> > > +     ret =3D reset_control_deassert(resetn);
> > > +     if (ret) {
> > > +             dev_err(&pdev->dev, "failed to deassert resetn pin, %d\=
n", ret);
> > > +             return ret;
> > > +     }
> > > +
> > > +     pm_runtime_enable(&pdev->dev);
> > > +     ret =3D pm_runtime_resume_and_get(&pdev->dev);
> > > +     if (ret < 0) {
> > > +             dev_err(&pdev->dev, "pm_runtime_resume_and_get failed: =
%d\n", ret);
> > > +             goto pm_disable;
> > > +     }
> >
> > If using runtime PM, why isn't the core IRQ code made aware of this
> > dependency by registering the device with irq_domain_set_pm_device()
> > instead of leaving it enabled forever?
> >
> Ouch will add irq_domain_set_pm_device() below.

You'll need a bit more than that. You'll either need to take a PM
reference on each alloc, or improve irq_chip_pm_{get,put}() to talk
the hierarchy.

That's probably a separate patch.

	M.

--=20
Without deviation from the norm, progress is not possible.
