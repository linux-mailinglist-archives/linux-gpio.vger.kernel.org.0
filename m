Return-Path: <linux-gpio-owner@vger.kernel.org>
X-Original-To: lists+linux-gpio@lfdr.de
Delivered-To: lists+linux-gpio@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 2001E563317
	for <lists+linux-gpio@lfdr.de>; Fri,  1 Jul 2022 14:03:29 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S232726AbiGAMD1 (ORCPT <rfc822;lists+linux-gpio@lfdr.de>);
        Fri, 1 Jul 2022 08:03:27 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:33794 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S229685AbiGAMD0 (ORCPT
        <rfc822;linux-gpio@vger.kernel.org>); Fri, 1 Jul 2022 08:03:26 -0400
Received: from mail-lf1-x132.google.com (mail-lf1-x132.google.com [IPv6:2a00:1450:4864:20::132])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id B2DB52DA98
        for <linux-gpio@vger.kernel.org>; Fri,  1 Jul 2022 05:03:21 -0700 (PDT)
Received: by mail-lf1-x132.google.com with SMTP id t19so2857742lfl.5
        for <linux-gpio@vger.kernel.org>; Fri, 01 Jul 2022 05:03:21 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=linaro.org; s=google;
        h=from:to:cc:subject:date:message-id:mime-version
         :content-transfer-encoding;
        bh=zTsPwE15UGqSH280YRhCd6evPk+nlVTEOjc7a+GG8K4=;
        b=TJqVnJLsIxqZ77MtwHXpffJqDjlZjnYtLcxpSSD62seH3GDwSuOPVapPnNjg9WDB5h
         K7iPHUouHoZsi+ewjZLNBRUo91Amp5ucA1bt2yZoQJYwgOjhCVtJp9Aryw3dNpyFZ4W2
         Sa0VanHnfUT8H2HuNqSa00bfeh3lW80CGXbhFtHcQg/lru4RIAItMVQw9WuqOVaJzfM6
         Ss+vCWLrOSaJbcRWbpxMAO4NFzzjfrggNX9yIplfcF7CYrhUu04FKV/ZLS+JKN0MFWYy
         jRaVnv/wnVZrb6NGvZvAMYvRBr+bhBGvy0TozYKj6vOrinBVzR3UU7LLkwAK+0N3XZzT
         eolw==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:mime-version
         :content-transfer-encoding;
        bh=zTsPwE15UGqSH280YRhCd6evPk+nlVTEOjc7a+GG8K4=;
        b=a6OWYOfNEY/aaGP+av3r8JAirFO66sjY/iPCnaGRnivMUgTcpoTPcDF7vui918Htuj
         u4fVZQgT4bXCscy5jZ0yXlPw1zIteyP/HJ04lZJUHocOD0OyQJemeMaIpxJMgBr8uVFY
         OudhbosOeNSpKnGPP2rtvCNrbn/n2mGErj3IPX1BKzmMwme0DxRJeSQcerh9OMuC41ah
         uveUN4xeUVdxkaYN09vGbUdC3vq8x3QA5ML4s2o5GEzRKzoRNCIUxAlR7eP2vHZg6MXF
         vFmlWwIFEA1AyHNY4TjKGsc9S8kUfY+fQm7x5zjWGVIRQkbU43mDpNcdOAgz+qv5N4OW
         kzdQ==
X-Gm-Message-State: AJIora8CpAPnwnDJ57WCBzMdc74+IdZ0bg0J77Ucq1j+iXFEAnbeB3cB
        rySIzl6tnysle2MNstPdMWD4ugMyJY1Cjg==
X-Google-Smtp-Source: AGRyM1u5dC5Y+YvgMlwrhAP3SfghmhZ8NtUlHjPZpcNswPZ/roIgC7sFc4APq1JQuWPoL6IuWBN59g==
X-Received: by 2002:a05:6512:2289:b0:481:1d4f:ac9d with SMTP id f9-20020a056512228900b004811d4fac9dmr9443656lfu.510.1656676998267;
        Fri, 01 Jul 2022 05:03:18 -0700 (PDT)
Received: from localhost.localdomain (c-fdcc225c.014-348-6c756e10.bbcust.telenor.se. [92.34.204.253])
        by smtp.gmail.com with ESMTPSA id s14-20020a19770e000000b0047faefd9f24sm3600069lfc.207.2022.07.01.05.03.16
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Fri, 01 Jul 2022 05:03:17 -0700 (PDT)
From:   Linus Walleij <linus.walleij@linaro.org>
To:     Sekhar Nori <nsekhar@ti.com>,
        Bartosz Golaszewski <bgolaszewski@baylibre.com>
Cc:     linux-arm-kernel@lists.infradead.org, linux-gpio@vger.kernel.org,
        Arnd Bergmann <arnd@kernel.org>,
        Linus Walleij <linus.walleij@linaro.org>,
        Matt Porter <mporter@konsulko.com>
Subject: [PATCH] ARM: davinci: Delete DM644x board files
Date:   Fri,  1 Jul 2022 14:01:11 +0200
Message-Id: <20220701120111.779348-1-linus.walleij@linaro.org>
X-Mailer: git-send-email 2.36.1
MIME-Version: 1.0
Content-Type: text/plain; charset=y
Content-Transfer-Encoding: 8bit
X-Spam-Status: No, score=-2.1 required=5.0 tests=BAYES_00,DKIM_SIGNED,
        DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_NONE,
        SPF_HELO_NONE,SPF_PASS,T_SCC_BODY_TEXT_LINE autolearn=ham
        autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-gpio.vger.kernel.org>
X-Mailing-List: linux-gpio@vger.kernel.org

The interest of maintaining the DaVinci DM644x board files seems
very low. Patches to convert the EVM board to use GPIO descriptors
has not been reviewed, tested or merged for several merge
windows in a row, see link below.

When I look in the logs for the board files I see nothing but
generic kernel maintenance and no testing on real hardware for
years.

I conclude the DM644x board files are unused and can be deleted.

Cc: Arnd Bergmann <arnd@kernel.org>
Cc: Matt Porter <mporter@konsulko.com>
Cc: Sekhar Nori <nsekhar@ti.com>
Cc: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Link: https://lore.kernel.org/linux-arm-kernel/20220507124536.171930-1-linus.walleij@linaro.org/
Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
---
 arch/arm/mach-davinci/Kconfig             |  27 -
 arch/arm/mach-davinci/Makefile            |   4 -
 arch/arm/mach-davinci/board-dm644x-evm.c  | 928 ----------------------
 arch/arm/mach-davinci/board-neuros-osd2.c | 238 ------
 arch/arm/mach-davinci/board-sffsdr.c      | 151 ----
 arch/arm/mach-davinci/dm644x.c            | 765 ------------------
 6 files changed, 2113 deletions(-)
 delete mode 100644 arch/arm/mach-davinci/board-dm644x-evm.c
 delete mode 100644 arch/arm/mach-davinci/board-neuros-osd2.c
 delete mode 100644 arch/arm/mach-davinci/board-sffsdr.c
 delete mode 100644 arch/arm/mach-davinci/dm644x.c

diff --git a/arch/arm/mach-davinci/Kconfig b/arch/arm/mach-davinci/Kconfig
index 008cbc2ab867..91dc05fe642f 100644
--- a/arch/arm/mach-davinci/Kconfig
+++ b/arch/arm/mach-davinci/Kconfig
@@ -19,11 +19,6 @@ config ARCH_DAVINCI_DMx
 
 comment "DaVinci Core Type"
 
-config ARCH_DAVINCI_DM644x
-	bool "DaVinci 644x based system"
-	select DAVINCI_AINTC
-	select ARCH_DAVINCI_DMx
-
 config ARCH_DAVINCI_DM355
 	bool "DaVinci 355 based system"
 	select DAVINCI_AINTC
@@ -67,28 +62,6 @@ config MACH_DA8XX_DT
 	  Say y here to include support for TI DaVinci DA850 based using
 	  Flattened Device Tree. More information at Documentation/devicetree
 
-config MACH_DAVINCI_EVM
-	bool "TI DM644x EVM"
-	default ARCH_DAVINCI_DM644x
-	depends on ARCH_DAVINCI_DM644x
-	help
-	  Configure this option to specify the whether the board used
-	  for development is a DM644x EVM
-
-config MACH_SFFSDR
-	bool "Lyrtech SFFSDR"
-	depends on ARCH_DAVINCI_DM644x
-	help
-	  Say Y here to select the Lyrtech Small Form Factor
-	  Software Defined Radio (SFFSDR) board.
-
-config MACH_NEUROS_OSD2
-	bool "Neuros OSD2 Open Television Set Top Box"
-	depends on ARCH_DAVINCI_DM644x
-	help
-	  Configure this option to specify the whether the board used
-	  for development is a Neuros OSD2 Open Set Top Box.
-
 config MACH_DAVINCI_DM355_EVM
 	bool "TI DM355 EVM"
 	default ARCH_DAVINCI_DM355
diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index b04c084b707e..5da1875d880f 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -10,7 +10,6 @@ obj-y 					:= serial.o usb.o common.o sram.o
 obj-$(CONFIG_DAVINCI_MUX)		+= mux.o
 
 # Chip specific
-obj-$(CONFIG_ARCH_DAVINCI_DM644x)       += dm644x.o devices.o
 obj-$(CONFIG_ARCH_DAVINCI_DM355)        += dm355.o devices.o
 obj-$(CONFIG_ARCH_DAVINCI_DM646x)       += dm646x.o devices.o
 obj-$(CONFIG_ARCH_DAVINCI_DM365)	+= dm365.o devices.o
@@ -19,9 +18,6 @@ obj-$(CONFIG_ARCH_DAVINCI_DA850)	+= da850.o devices-da8xx.o usb-da8xx.o
 
 # Board specific
 obj-$(CONFIG_MACH_DA8XX_DT)		+= da8xx-dt.o pdata-quirks.o
-obj-$(CONFIG_MACH_DAVINCI_EVM)  	+= board-dm644x-evm.o
-obj-$(CONFIG_MACH_SFFSDR)		+= board-sffsdr.o
-obj-$(CONFIG_MACH_NEUROS_OSD2)		+= board-neuros-osd2.o
 obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)	+= board-dm355-evm.o
 obj-$(CONFIG_MACH_DM355_LEOPARD)	+= board-dm355-leopard.o
 obj-$(CONFIG_MACH_DAVINCI_DM6467_EVM)	+= board-dm646x-evm.o
diff --git a/arch/arm/mach-davinci/board-dm644x-evm.c b/arch/arm/mach-davinci/board-dm644x-evm.c
deleted file mode 100644
index 9f405af36a6f..000000000000
--- a/arch/arm/mach-davinci/board-dm644x-evm.c
+++ /dev/null
@@ -1,928 +0,0 @@
-/*
- * TI DaVinci EVM board support
- *
- * Author: Kevin Hilman, MontaVista Software, Inc. <source@mvista.com>
- *
- * 2007 (c) MontaVista Software, Inc. This file is licensed under
- * the terms of the GNU General Public License version 2. This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/dma-mapping.h>
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-#include <linux/gpio/machine.h>
-#include <linux/i2c.h>
-#include <linux/platform_data/pcf857x.h>
-#include <linux/platform_data/gpio-davinci.h>
-#include <linux/property.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/rawnand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/mtd/physmap.h>
-#include <linux/nvmem-provider.h>
-#include <linux/phy.h>
-#include <linux/clk.h>
-#include <linux/videodev2.h>
-#include <linux/v4l2-dv-timings.h>
-#include <linux/export.h>
-#include <linux/leds.h>
-#include <linux/regulator/fixed.h>
-#include <linux/regulator/machine.h>
-
-#include <media/i2c/tvp514x.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-
-#include <linux/platform_data/i2c-davinci.h>
-#include <linux/platform_data/mtd-davinci.h>
-#include <linux/platform_data/mmc-davinci.h>
-#include <linux/platform_data/usb-davinci.h>
-#include <linux/platform_data/mtd-davinci-aemif.h>
-#include <linux/platform_data/ti-aemif.h>
-
-#include "davinci.h"
-#include "common.h"
-#include "mux.h"
-#include "serial.h"
-#include "irqs.h"
-
-#define DM644X_EVM_PHY_ID		"davinci_mdio-0:01"
-#define LXT971_PHY_ID	(0x001378e2)
-#define LXT971_PHY_MASK	(0xfffffff0)
-
-static struct mtd_partition davinci_evm_norflash_partitions[] = {
-	/* bootloader (UBL, U-Boot, etc) in first 5 sectors */
-	{
-		.name		= "bootloader",
-		.offset		= 0,
-		.size		= 5 * SZ_64K,
-		.mask_flags	= MTD_WRITEABLE, /* force read-only */
-	},
-	/* bootloader params in the next 1 sectors */
-	{
-		.name		= "params",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= SZ_64K,
-		.mask_flags	= 0,
-	},
-	/* kernel */
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= SZ_2M,
-		.mask_flags	= 0
-	},
-	/* file system */
-	{
-		.name		= "filesystem",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-		.mask_flags	= 0
-	}
-};
-
-static struct physmap_flash_data davinci_evm_norflash_data = {
-	.width		= 2,
-	.parts		= davinci_evm_norflash_partitions,
-	.nr_parts	= ARRAY_SIZE(davinci_evm_norflash_partitions),
-};
-
-/* NOTE: CFI probe will correctly detect flash part as 32M, but EMIF
- * limits addresses to 16M, so using addresses past 16M will wrap */
-static struct resource davinci_evm_norflash_resource = {
-	.start		= DM644X_ASYNC_EMIF_DATA_CE0_BASE,
-	.end		= DM644X_ASYNC_EMIF_DATA_CE0_BASE + SZ_16M - 1,
-	.flags		= IORESOURCE_MEM,
-};
-
-static struct platform_device davinci_evm_norflash_device = {
-	.name		= "physmap-flash",
-	.id		= 0,
-	.dev		= {
-		.platform_data	= &davinci_evm_norflash_data,
-	},
-	.num_resources	= 1,
-	.resource	= &davinci_evm_norflash_resource,
-};
-
-/* DM644x EVM includes a 64 MByte small-page NAND flash (16K blocks).
- * It may used instead of the (default) NOR chip to boot, using TI's
- * tools to install the secondary boot loader (UBL) and U-Boot.
- */
-static struct mtd_partition davinci_evm_nandflash_partition[] = {
-	/* Bootloader layout depends on whose u-boot is installed, but we
-	 * can hide all the details.
-	 *  - block 0 for u-boot environment ... in mainline u-boot
-	 *  - block 1 for UBL (plus up to four backup copies in blocks 2..5)
-	 *  - blocks 6...? for u-boot
-	 *  - blocks 16..23 for u-boot environment ... in TI's u-boot
-	 */
-	{
-		.name		= "bootloader",
-		.offset		= 0,
-		.size		= SZ_256K + SZ_128K,
-		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
-	},
-	/* Kernel */
-	{
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= SZ_4M,
-		.mask_flags	= 0,
-	},
-	/* File system (older GIT kernels started this on the 5MB mark) */
-	{
-		.name		= "filesystem",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-		.mask_flags	= 0,
-	}
-	/* A few blocks at end hold a flash BBT ... created by TI's CCS
-	 * using flashwriter_nand.out, but ignored by TI's versions of
-	 * Linux and u-boot.  We boot faster by using them.
-	 */
-};
-
-static struct davinci_aemif_timing davinci_evm_nandflash_timing = {
-	.wsetup		= 20,
-	.wstrobe	= 40,
-	.whold		= 20,
-	.rsetup		= 10,
-	.rstrobe	= 40,
-	.rhold		= 10,
-	.ta		= 40,
-};
-
-static struct davinci_nand_pdata davinci_evm_nandflash_data = {
-	.core_chipsel	= 0,
-	.parts		= davinci_evm_nandflash_partition,
-	.nr_parts	= ARRAY_SIZE(davinci_evm_nandflash_partition),
-	.engine_type	= NAND_ECC_ENGINE_TYPE_ON_HOST,
-	.ecc_bits	= 1,
-	.bbt_options	= NAND_BBT_USE_FLASH,
-	.timing		= &davinci_evm_nandflash_timing,
-};
-
-static struct resource davinci_evm_nandflash_resource[] = {
-	{
-		.start		= DM644X_ASYNC_EMIF_DATA_CE0_BASE,
-		.end		= DM644X_ASYNC_EMIF_DATA_CE0_BASE + SZ_16M - 1,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= DM644X_ASYNC_EMIF_CONTROL_BASE,
-		.end		= DM644X_ASYNC_EMIF_CONTROL_BASE + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-};
-
-static struct resource davinci_evm_aemif_resource[] = {
-	{
-		.start		= DM644X_ASYNC_EMIF_CONTROL_BASE,
-		.end		= DM644X_ASYNC_EMIF_CONTROL_BASE + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-};
-
-static struct aemif_abus_data davinci_evm_aemif_abus_data[] = {
-	{
-		.cs		= 1,
-	},
-};
-
-static struct platform_device davinci_evm_nandflash_devices[] = {
-	{
-		.name		= "davinci_nand",
-		.id		= 0,
-		.dev		= {
-			.platform_data	= &davinci_evm_nandflash_data,
-		},
-		.num_resources	= ARRAY_SIZE(davinci_evm_nandflash_resource),
-		.resource	= davinci_evm_nandflash_resource,
-	},
-};
-
-static struct aemif_platform_data davinci_evm_aemif_pdata = {
-	.abus_data = davinci_evm_aemif_abus_data,
-	.num_abus_data = ARRAY_SIZE(davinci_evm_aemif_abus_data),
-	.sub_devices = davinci_evm_nandflash_devices,
-	.num_sub_devices = ARRAY_SIZE(davinci_evm_nandflash_devices),
-};
-
-static struct platform_device davinci_evm_aemif_device = {
-	.name			= "ti-aemif",
-	.id			= -1,
-	.dev = {
-		.platform_data	= &davinci_evm_aemif_pdata,
-	},
-	.resource		= davinci_evm_aemif_resource,
-	.num_resources		= ARRAY_SIZE(davinci_evm_aemif_resource),
-};
-
-static u64 davinci_fb_dma_mask = DMA_BIT_MASK(32);
-
-static struct platform_device davinci_fb_device = {
-	.name		= "davincifb",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= &davinci_fb_dma_mask,
-		.coherent_dma_mask      = DMA_BIT_MASK(32),
-	},
-	.num_resources = 0,
-};
-
-static struct tvp514x_platform_data dm644xevm_tvp5146_pdata = {
-	.clk_polarity = 0,
-	.hs_polarity = 1,
-	.vs_polarity = 1
-};
-
-#define TVP514X_STD_ALL	(V4L2_STD_NTSC | V4L2_STD_PAL)
-/* Inputs available at the TVP5146 */
-static struct v4l2_input dm644xevm_tvp5146_inputs[] = {
-	{
-		.index = 0,
-		.name = "Composite",
-		.type = V4L2_INPUT_TYPE_CAMERA,
-		.std = TVP514X_STD_ALL,
-	},
-	{
-		.index = 1,
-		.name = "S-Video",
-		.type = V4L2_INPUT_TYPE_CAMERA,
-		.std = TVP514X_STD_ALL,
-	},
-};
-
-/*
- * this is the route info for connecting each input to decoder
- * ouput that goes to vpfe. There is a one to one correspondence
- * with tvp5146_inputs
- */
-static struct vpfe_route dm644xevm_tvp5146_routes[] = {
-	{
-		.input = INPUT_CVBS_VI2B,
-		.output = OUTPUT_10BIT_422_EMBEDDED_SYNC,
-	},
-	{
-		.input = INPUT_SVIDEO_VI2C_VI1C,
-		.output = OUTPUT_10BIT_422_EMBEDDED_SYNC,
-	},
-};
-
-static struct vpfe_subdev_info dm644xevm_vpfe_sub_devs[] = {
-	{
-		.name = "tvp5146",
-		.grp_id = 0,
-		.num_inputs = ARRAY_SIZE(dm644xevm_tvp5146_inputs),
-		.inputs = dm644xevm_tvp5146_inputs,
-		.routes = dm644xevm_tvp5146_routes,
-		.can_route = 1,
-		.ccdc_if_params = {
-			.if_type = VPFE_BT656,
-			.hdpol = VPFE_PINPOL_POSITIVE,
-			.vdpol = VPFE_PINPOL_POSITIVE,
-		},
-		.board_info = {
-			I2C_BOARD_INFO("tvp5146", 0x5d),
-			.platform_data = &dm644xevm_tvp5146_pdata,
-		},
-	},
-};
-
-static struct vpfe_config dm644xevm_capture_cfg = {
-	.num_subdevs = ARRAY_SIZE(dm644xevm_vpfe_sub_devs),
-	.i2c_adapter_id = 1,
-	.sub_devs = dm644xevm_vpfe_sub_devs,
-	.card_name = "DM6446 EVM",
-	.ccdc = "DM6446 CCDC",
-};
-
-static struct platform_device rtc_dev = {
-	.name           = "rtc_davinci_evm",
-	.id             = -1,
-};
-
-/*----------------------------------------------------------------------*/
-#ifdef CONFIG_I2C
-/*
- * I2C GPIO expanders
- */
-
-#define PCF_Uxx_BASE(x)	(DAVINCI_N_GPIO + ((x) * 8))
-
-
-/* U2 -- LEDs */
-
-static struct gpio_led evm_leds[] = {
-	{ .name = "DS8", .active_low = 1,
-		.default_trigger = "heartbeat", },
-	{ .name = "DS7", .active_low = 1, },
-	{ .name = "DS6", .active_low = 1, },
-	{ .name = "DS5", .active_low = 1, },
-	{ .name = "DS4", .active_low = 1, },
-	{ .name = "DS3", .active_low = 1, },
-	{ .name = "DS2", .active_low = 1,
-		.default_trigger = "mmc0", },
-	{ .name = "DS1", .active_low = 1,
-		.default_trigger = "disk-activity", },
-};
-
-static const struct gpio_led_platform_data evm_led_data = {
-	.num_leds	= ARRAY_SIZE(evm_leds),
-	.leds		= evm_leds,
-};
-
-static struct platform_device *evm_led_dev;
-
-static int
-evm_led_setup(struct i2c_client *client, int gpio, unsigned ngpio, void *c)
-{
-	struct gpio_led *leds = evm_leds;
-	int status;
-
-	while (ngpio--) {
-		leds->gpio = gpio++;
-		leds++;
-	}
-
-	/* what an extremely annoying way to be forced to handle
-	 * device unregistration ...
-	 */
-	evm_led_dev = platform_device_alloc("leds-gpio", 0);
-	platform_device_add_data(evm_led_dev,
-			&evm_led_data, sizeof evm_led_data);
-
-	evm_led_dev->dev.parent = &client->dev;
-	status = platform_device_add(evm_led_dev);
-	if (status < 0) {
-		platform_device_put(evm_led_dev);
-		evm_led_dev = NULL;
-	}
-	return status;
-}
-
-static void
-evm_led_teardown(struct i2c_client *client, int gpio, unsigned ngpio, void *c)
-{
-	if (evm_led_dev) {
-		platform_device_unregister(evm_led_dev);
-		evm_led_dev = NULL;
-	}
-}
-
-static struct pcf857x_platform_data pcf_data_u2 = {
-	.gpio_base	= PCF_Uxx_BASE(0),
-	.setup		= evm_led_setup,
-	.teardown	= evm_led_teardown,
-};
-
-
-/* U18 - A/V clock generator and user switch */
-
-static int sw_gpio;
-
-static ssize_t
-sw_show(struct device *d, struct device_attribute *a, char *buf)
-{
-	char *s = gpio_get_value_cansleep(sw_gpio) ? "on\n" : "off\n";
-
-	strcpy(buf, s);
-	return strlen(s);
-}
-
-static DEVICE_ATTR(user_sw, S_IRUGO, sw_show, NULL);
-
-static int
-evm_u18_setup(struct i2c_client *client, int gpio, unsigned ngpio, void *c)
-{
-	int	status;
-
-	/* export dip switch option */
-	sw_gpio = gpio + 7;
-	status = gpio_request(sw_gpio, "user_sw");
-	if (status == 0)
-		status = gpio_direction_input(sw_gpio);
-	if (status == 0)
-		status = device_create_file(&client->dev, &dev_attr_user_sw);
-	else
-		gpio_free(sw_gpio);
-	if (status != 0)
-		sw_gpio = -EINVAL;
-
-	/* audio PLL:  48 kHz (vs 44.1 or 32), single rate (vs double) */
-	gpio_request(gpio + 3, "pll_fs2");
-	gpio_direction_output(gpio + 3, 0);
-
-	gpio_request(gpio + 2, "pll_fs1");
-	gpio_direction_output(gpio + 2, 0);
-
-	gpio_request(gpio + 1, "pll_sr");
-	gpio_direction_output(gpio + 1, 0);
-
-	return 0;
-}
-
-static void
-evm_u18_teardown(struct i2c_client *client, int gpio, unsigned ngpio, void *c)
-{
-	gpio_free(gpio + 1);
-	gpio_free(gpio + 2);
-	gpio_free(gpio + 3);
-
-	if (sw_gpio > 0) {
-		device_remove_file(&client->dev, &dev_attr_user_sw);
-		gpio_free(sw_gpio);
-	}
-}
-
-static struct pcf857x_platform_data pcf_data_u18 = {
-	.gpio_base	= PCF_Uxx_BASE(1),
-	.n_latch	= (1 << 3) | (1 << 2) | (1 << 1),
-	.setup		= evm_u18_setup,
-	.teardown	= evm_u18_teardown,
-};
-
-
-/* U35 - various I/O signals used to manage USB, CF, ATA, etc */
-
-static int
-evm_u35_setup(struct i2c_client *client, int gpio, unsigned ngpio, void *c)
-{
-	/* p0 = nDRV_VBUS (initial:  don't supply it) */
-	gpio_request(gpio + 0, "nDRV_VBUS");
-	gpio_direction_output(gpio + 0, 1);
-
-	/* p1 = VDDIMX_EN */
-	gpio_request(gpio + 1, "VDDIMX_EN");
-	gpio_direction_output(gpio + 1, 1);
-
-	/* p2 = VLYNQ_EN */
-	gpio_request(gpio + 2, "VLYNQ_EN");
-	gpio_direction_output(gpio + 2, 1);
-
-	/* p3 = n3V3_CF_RESET (initial: stay in reset) */
-	gpio_request(gpio + 3, "nCF_RESET");
-	gpio_direction_output(gpio + 3, 0);
-
-	/* (p4 unused) */
-
-	/* p5 = 1V8_WLAN_RESET (initial: stay in reset) */
-	gpio_request(gpio + 5, "WLAN_RESET");
-	gpio_direction_output(gpio + 5, 1);
-
-	/* p6 = nATA_SEL (initial: select) */
-	gpio_request(gpio + 6, "nATA_SEL");
-	gpio_direction_output(gpio + 6, 0);
-
-	/* p7 = nCF_SEL (initial: deselect) */
-	gpio_request(gpio + 7, "nCF_SEL");
-	gpio_direction_output(gpio + 7, 1);
-
-	return 0;
-}
-
-static void
-evm_u35_teardown(struct i2c_client *client, int gpio, unsigned ngpio, void *c)
-{
-	gpio_free(gpio + 7);
-	gpio_free(gpio + 6);
-	gpio_free(gpio + 5);
-	gpio_free(gpio + 3);
-	gpio_free(gpio + 2);
-	gpio_free(gpio + 1);
-	gpio_free(gpio + 0);
-}
-
-static struct pcf857x_platform_data pcf_data_u35 = {
-	.gpio_base	= PCF_Uxx_BASE(2),
-	.setup		= evm_u35_setup,
-	.teardown	= evm_u35_teardown,
-};
-
-/*----------------------------------------------------------------------*/
-
-/* Most of this EEPROM is unused, but U-Boot uses some data:
- *  - 0x7f00, 6 bytes Ethernet Address
- *  - 0x0039, 1 byte NTSC vs PAL (bit 0x80 == PAL)
- *  - ... newer boards may have more
- */
-
-static struct nvmem_cell_info dm644evm_nvmem_cells[] = {
-	{
-		.name		= "macaddr",
-		.offset		= 0x7f00,
-		.bytes		= ETH_ALEN,
-	}
-};
-
-static struct nvmem_cell_table dm644evm_nvmem_cell_table = {
-	.nvmem_name	= "1-00500",
-	.cells		= dm644evm_nvmem_cells,
-	.ncells		= ARRAY_SIZE(dm644evm_nvmem_cells),
-};
-
-static struct nvmem_cell_lookup dm644evm_nvmem_cell_lookup = {
-	.nvmem_name	= "1-00500",
-	.cell_name	= "macaddr",
-	.dev_id		= "davinci_emac.1",
-	.con_id		= "mac-address",
-};
-
-static const struct property_entry eeprom_properties[] = {
-	PROPERTY_ENTRY_U32("pagesize", 64),
-	{ }
-};
-
-static const struct software_node eeprom_node = {
-	.properties = eeprom_properties,
-};
-
-/*
- * MSP430 supports RTC, card detection, input from IR remote, and
- * a bit more.  It triggers interrupts on GPIO(7) from pressing
- * buttons on the IR remote, and for card detect switches.
- */
-static struct i2c_client *dm6446evm_msp;
-
-static int dm6446evm_msp_probe(struct i2c_client *client)
-{
-	dm6446evm_msp = client;
-	return 0;
-}
-
-static int dm6446evm_msp_remove(struct i2c_client *client)
-{
-	dm6446evm_msp = NULL;
-	return 0;
-}
-
-static const struct i2c_device_id dm6446evm_msp_ids[] = {
-	{ "dm6446evm_msp", 0, },
-	{ /* end of list */ },
-};
-
-static struct i2c_driver dm6446evm_msp_driver = {
-	.driver.name	= "dm6446evm_msp",
-	.id_table	= dm6446evm_msp_ids,
-	.probe_new	= dm6446evm_msp_probe,
-	.remove		= dm6446evm_msp_remove,
-};
-
-static int dm6444evm_msp430_get_pins(void)
-{
-	static const char txbuf[2] = { 2, 4, };
-	char buf[4];
-	struct i2c_msg msg[2] = {
-		{
-			.flags = 0,
-			.len = 2,
-			.buf = (void __force *)txbuf,
-		},
-		{
-			.flags = I2C_M_RD,
-			.len = 4,
-			.buf = buf,
-		},
-	};
-	int status;
-
-	if (!dm6446evm_msp)
-		return -ENXIO;
-
-	msg[0].addr = dm6446evm_msp->addr;
-	msg[1].addr = dm6446evm_msp->addr;
-
-	/* Command 4 == get input state, returns port 2 and port3 data
-	 *   S Addr W [A] len=2 [A] cmd=4 [A]
-	 *   RS Addr R [A] [len=4] A [cmd=4] A [port2] A [port3] N P
-	 */
-	status = i2c_transfer(dm6446evm_msp->adapter, msg, 2);
-	if (status < 0)
-		return status;
-
-	dev_dbg(&dm6446evm_msp->dev, "PINS: %4ph\n", buf);
-
-	return (buf[3] << 8) | buf[2];
-}
-
-static int dm6444evm_mmc_get_cd(int module)
-{
-	int status = dm6444evm_msp430_get_pins();
-
-	return (status < 0) ? status : !(status & BIT(1));
-}
-
-static int dm6444evm_mmc_get_ro(int module)
-{
-	int status = dm6444evm_msp430_get_pins();
-
-	return (status < 0) ? status : status & BIT(6 + 8);
-}
-
-static struct davinci_mmc_config dm6446evm_mmc_config = {
-	.get_cd		= dm6444evm_mmc_get_cd,
-	.get_ro		= dm6444evm_mmc_get_ro,
-	.wires		= 4,
-};
-
-static struct i2c_board_info __initdata i2c_info[] =  {
-	{
-		I2C_BOARD_INFO("dm6446evm_msp", 0x23),
-	},
-	{
-		I2C_BOARD_INFO("pcf8574", 0x38),
-		.platform_data	= &pcf_data_u2,
-	},
-	{
-		I2C_BOARD_INFO("pcf8574", 0x39),
-		.platform_data	= &pcf_data_u18,
-	},
-	{
-		I2C_BOARD_INFO("pcf8574", 0x3a),
-		.platform_data	= &pcf_data_u35,
-	},
-	{
-		I2C_BOARD_INFO("24c256", 0x50),
-		.swnode = &eeprom_node,
-	},
-	{
-		I2C_BOARD_INFO("tlv320aic33", 0x1b),
-	},
-};
-
-#define DM644X_I2C_SDA_PIN	GPIO_TO_PIN(2, 12)
-#define DM644X_I2C_SCL_PIN	GPIO_TO_PIN(2, 11)
-
-static struct gpiod_lookup_table i2c_recovery_gpiod_table = {
-	.dev_id = "i2c_davinci.1",
-	.table = {
-		GPIO_LOOKUP("davinci_gpio", DM644X_I2C_SDA_PIN, "sda",
-			    GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN),
-		GPIO_LOOKUP("davinci_gpio", DM644X_I2C_SCL_PIN, "scl",
-			    GPIO_ACTIVE_HIGH | GPIO_OPEN_DRAIN),
-		{ }
-	},
-};
-
-/* The msp430 uses a slow bitbanged I2C implementation (ergo 20 KHz),
- * which requires 100 usec of idle bus after i2c writes sent to it.
- */
-static struct davinci_i2c_platform_data i2c_pdata = {
-	.bus_freq	= 20 /* kHz */,
-	.bus_delay	= 100 /* usec */,
-	.gpio_recovery	= true,
-};
-
-static void __init evm_init_i2c(void)
-{
-	gpiod_add_lookup_table(&i2c_recovery_gpiod_table);
-	davinci_init_i2c(&i2c_pdata);
-	i2c_add_driver(&dm6446evm_msp_driver);
-	i2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));
-}
-#endif
-
-/* Fixed regulator support */
-static struct regulator_consumer_supply fixed_supplies_3_3v[] = {
-	/* Baseboard 3.3V: 5V -> TPS54310PWP -> 3.3V */
-	REGULATOR_SUPPLY("AVDD", "1-001b"),
-	REGULATOR_SUPPLY("DRVDD", "1-001b"),
-};
-
-static struct regulator_consumer_supply fixed_supplies_1_8v[] = {
-	/* Baseboard 1.8V: 5V -> TPS54310PWP -> 1.8V */
-	REGULATOR_SUPPLY("IOVDD", "1-001b"),
-	REGULATOR_SUPPLY("DVDD", "1-001b"),
-};
-
-#define VENC_STD_ALL	(V4L2_STD_NTSC | V4L2_STD_PAL)
-
-/* venc standard timings */
-static struct vpbe_enc_mode_info dm644xevm_enc_std_timing[] = {
-	{
-		.name		= "ntsc",
-		.timings_type	= VPBE_ENC_STD,
-		.std_id		= V4L2_STD_NTSC,
-		.interlaced	= 1,
-		.xres		= 720,
-		.yres		= 480,
-		.aspect		= {11, 10},
-		.fps		= {30000, 1001},
-		.left_margin	= 0x79,
-		.upper_margin	= 0x10,
-	},
-	{
-		.name		= "pal",
-		.timings_type	= VPBE_ENC_STD,
-		.std_id		= V4L2_STD_PAL,
-		.interlaced	= 1,
-		.xres		= 720,
-		.yres		= 576,
-		.aspect		= {54, 59},
-		.fps		= {25, 1},
-		.left_margin	= 0x7e,
-		.upper_margin	= 0x16,
-	},
-};
-
-/* venc dv preset timings */
-static struct vpbe_enc_mode_info dm644xevm_enc_preset_timing[] = {
-	{
-		.name		= "480p59_94",
-		.timings_type	= VPBE_ENC_DV_TIMINGS,
-		.dv_timings	= V4L2_DV_BT_CEA_720X480P59_94,
-		.interlaced	= 0,
-		.xres		= 720,
-		.yres		= 480,
-		.aspect		= {1, 1},
-		.fps		= {5994, 100},
-		.left_margin	= 0x80,
-		.upper_margin	= 0x20,
-	},
-	{
-		.name		= "576p50",
-		.timings_type	= VPBE_ENC_DV_TIMINGS,
-		.dv_timings	= V4L2_DV_BT_CEA_720X576P50,
-		.interlaced	= 0,
-		.xres		= 720,
-		.yres		= 576,
-		.aspect		= {1, 1},
-		.fps		= {50, 1},
-		.left_margin	= 0x7e,
-		.upper_margin	= 0x30,
-	},
-};
-
-/*
- * The outputs available from VPBE + encoders. Keep the order same
- * as that of encoders. First those from venc followed by that from
- * encoders. Index in the output refers to index on a particular encoder.
- * Driver uses this index to pass it to encoder when it supports more
- * than one output. Userspace applications use index of the array to
- * set an output.
- */
-static struct vpbe_output dm644xevm_vpbe_outputs[] = {
-	{
-		.output		= {
-			.index		= 0,
-			.name		= "Composite",
-			.type		= V4L2_OUTPUT_TYPE_ANALOG,
-			.std		= VENC_STD_ALL,
-			.capabilities	= V4L2_OUT_CAP_STD,
-		},
-		.subdev_name	= DM644X_VPBE_VENC_SUBDEV_NAME,
-		.default_mode	= "ntsc",
-		.num_modes	= ARRAY_SIZE(dm644xevm_enc_std_timing),
-		.modes		= dm644xevm_enc_std_timing,
-	},
-	{
-		.output		= {
-			.index		= 1,
-			.name		= "Component",
-			.type		= V4L2_OUTPUT_TYPE_ANALOG,
-			.capabilities	= V4L2_OUT_CAP_DV_TIMINGS,
-		},
-		.subdev_name	= DM644X_VPBE_VENC_SUBDEV_NAME,
-		.default_mode	= "480p59_94",
-		.num_modes	= ARRAY_SIZE(dm644xevm_enc_preset_timing),
-		.modes		= dm644xevm_enc_preset_timing,
-	},
-};
-
-static struct vpbe_config dm644xevm_display_cfg = {
-	.module_name	= "dm644x-vpbe-display",
-	.i2c_adapter_id	= 1,
-	.osd		= {
-		.module_name	= DM644X_VPBE_OSD_SUBDEV_NAME,
-	},
-	.venc		= {
-		.module_name	= DM644X_VPBE_VENC_SUBDEV_NAME,
-	},
-	.num_outputs	= ARRAY_SIZE(dm644xevm_vpbe_outputs),
-	.outputs	= dm644xevm_vpbe_outputs,
-};
-
-static struct platform_device *davinci_evm_devices[] __initdata = {
-	&davinci_fb_device,
-	&rtc_dev,
-};
-
-static void __init
-davinci_evm_map_io(void)
-{
-	dm644x_init();
-}
-
-static int davinci_phy_fixup(struct phy_device *phydev)
-{
-	unsigned int control;
-	/* CRITICAL: Fix for increasing PHY signal drive strength for
-	 * TX lockup issue. On DaVinci EVM, the Intel LXT971 PHY
-	 * signal strength was low causing  TX to fail randomly. The
-	 * fix is to Set bit 11 (Increased MII drive strength) of PHY
-	 * register 26 (Digital Config register) on this phy. */
-	control = phy_read(phydev, 26);
-	phy_write(phydev, 26, (control | 0x800));
-	return 0;
-}
-
-#define HAS_ATA		(IS_ENABLED(CONFIG_BLK_DEV_PALMCHIP_BK3710) || \
-			 IS_ENABLED(CONFIG_PATA_BK3710))
-
-#define HAS_NOR		IS_ENABLED(CONFIG_MTD_PHYSMAP)
-
-#define HAS_NAND	IS_ENABLED(CONFIG_MTD_NAND_DAVINCI)
-
-#define GPIO_nVBUS_DRV		160
-
-static struct gpiod_lookup_table dm644evm_usb_gpio_table = {
-	.dev_id = "musb-davinci",
-	.table = {
-		GPIO_LOOKUP("davinci_gpio", GPIO_nVBUS_DRV, NULL,
-			    GPIO_ACTIVE_HIGH),
-		{ }
-	},
-};
-
-static __init void davinci_evm_init(void)
-{
-	int ret;
-	struct clk *aemif_clk;
-	struct davinci_soc_info *soc_info = &davinci_soc_info;
-
-	dm644x_register_clocks();
-
-	regulator_register_always_on(0, "fixed-dummy", fixed_supplies_1_8v,
-				     ARRAY_SIZE(fixed_supplies_1_8v), 1800000);
-	regulator_register_always_on(1, "fixed-dummy", fixed_supplies_3_3v,
-				     ARRAY_SIZE(fixed_supplies_3_3v), 3300000);
-
-	dm644x_init_devices();
-
-	ret = dm644x_gpio_register();
-	if (ret)
-		pr_warn("%s: GPIO init failed: %d\n", __func__, ret);
-
-	aemif_clk = clk_get(NULL, "aemif");
-	clk_prepare_enable(aemif_clk);
-
-	if (HAS_ATA) {
-		if (HAS_NAND || HAS_NOR)
-			pr_warn("WARNING: both IDE and Flash are enabled, but they share AEMIF pins\n"
-				"\tDisable IDE for NAND/NOR support\n");
-		davinci_init_ide();
-	} else if (HAS_NAND || HAS_NOR) {
-		davinci_cfg_reg(DM644X_HPIEN_DISABLE);
-		davinci_cfg_reg(DM644X_ATAEN_DISABLE);
-
-		/* only one device will be jumpered and detected */
-		if (HAS_NAND) {
-			platform_device_register(&davinci_evm_aemif_device);
-#ifdef CONFIG_I2C
-			evm_leds[7].default_trigger = "nand-disk";
-#endif
-			if (HAS_NOR)
-				pr_warn("WARNING: both NAND and NOR flash are enabled; disable one of them.\n");
-		} else if (HAS_NOR)
-			platform_device_register(&davinci_evm_norflash_device);
-	}
-
-	platform_add_devices(davinci_evm_devices,
-			     ARRAY_SIZE(davinci_evm_devices));
-#ifdef CONFIG_I2C
-	nvmem_add_cell_table(&dm644evm_nvmem_cell_table);
-	nvmem_add_cell_lookups(&dm644evm_nvmem_cell_lookup, 1);
-	evm_init_i2c();
-	davinci_setup_mmc(0, &dm6446evm_mmc_config);
-#endif
-	dm644x_init_video(&dm644xevm_capture_cfg, &dm644xevm_display_cfg);
-
-	davinci_serial_init(dm644x_serial_device);
-	dm644x_init_asp();
-
-	/* irlml6401 switches over 1A, in under 8 msec */
-	gpiod_add_lookup_table(&dm644evm_usb_gpio_table);
-	davinci_setup_usb(1000, 8);
-
-	if (IS_BUILTIN(CONFIG_PHYLIB)) {
-		soc_info->emac_pdata->phy_id = DM644X_EVM_PHY_ID;
-		/* Register the fixup for PHY on DaVinci */
-		phy_register_fixup_for_uid(LXT971_PHY_ID, LXT971_PHY_MASK,
-						davinci_phy_fixup);
-	}
-}
-
-MACHINE_START(DAVINCI_EVM, "DaVinci DM644x EVM")
-	/* Maintainer: MontaVista Software <source@mvista.com> */
-	.atag_offset  = 0x100,
-	.map_io	      = davinci_evm_map_io,
-	.init_irq     = dm644x_init_irq,
-	.init_time	= dm644x_init_time,
-	.init_machine = davinci_evm_init,
-	.init_late	= davinci_init_late,
-	.dma_zone_size	= SZ_128M,
-MACHINE_END
diff --git a/arch/arm/mach-davinci/board-neuros-osd2.c b/arch/arm/mach-davinci/board-neuros-osd2.c
deleted file mode 100644
index 94be492b8a9e..000000000000
--- a/arch/arm/mach-davinci/board-neuros-osd2.c
+++ /dev/null
@@ -1,238 +0,0 @@
-/*
- * Neuros Technologies OSD2 board support
- *
- * Modified from original 644X-EVM board support.
- * 2008 (c) Neuros Technology, LLC.
- * 2009 (c) Jorge Luis Zapata Muga <jorgeluis.zapata@gmail.com>
- * 2009 (c) Andrey A. Porodko <Andrey.Porodko@gmail.com>
- *
- * The Neuros OSD 2.0 is the hardware component of the Neuros Open
- * Internet Television Platform. Hardware is very close to TI
- * DM644X-EVM board. It has:
- * 	DM6446M02 module with 256MB NAND, 256MB RAM, TLV320AIC32 AIC,
- * 	USB, Ethernet, SD/MMC, UART, THS8200, TVP7000 for video.
- * 	Additionally realtime clock, IR remote control receiver,
- * 	IR Blaster based on MSP430 (firmware although is different
- * 	from used in DM644X-EVM), internal ATA-6 3.5‚Äù HDD drive
- * 	with PATA interface, two muxed red-green leds.
- *
- * For more information please refer to
- * 		http://wiki.neurostechnology.com/index.php/OSD_2.0_HD
- *
- * This file is licensed under the terms of the GNU General Public
- * License version 2. This program is licensed "as is" without any
- * warranty of any kind, whether express or implied.
- */
-#include <linux/platform_device.h>
-#include <linux/gpio.h>
-#include <linux/leds.h>
-#include <linux/mtd/partitions.h>
-#include <linux/platform_data/gpio-davinci.h>
-#include <linux/platform_data/i2c-davinci.h>
-#include <linux/platform_data/mmc-davinci.h>
-#include <linux/platform_data/mtd-davinci.h>
-#include <linux/platform_data/usb-davinci.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-
-#include "common.h"
-#include "serial.h"
-#include "mux.h"
-#include "davinci.h"
-
-#define NEUROS_OSD2_PHY_ID		"davinci_mdio-0:01"
-#define LXT971_PHY_ID			0x001378e2
-#define LXT971_PHY_MASK			0xfffffff0
-
-#define	NTOSD2_AUDIOSOC_I2C_ADDR	0x18
-#define	NTOSD2_MSP430_I2C_ADDR		0x59
-#define	NTOSD2_MSP430_IRQ		2
-
-/* Neuros OSD2 has a Samsung 256 MByte NAND flash (Dev ID of 0xAA,
- * 2048 blocks in the device, 64 pages per block, 2048 bytes per
- * page.
- */
-
-#define NAND_BLOCK_SIZE		SZ_128K
-
-static struct mtd_partition davinci_ntosd2_nandflash_partition[] = {
-	{
-		/* UBL (a few copies) plus U-Boot */
-		.name		= "bootloader",
-		.offset		= 0,
-		.size		= 15 * NAND_BLOCK_SIZE,
-		.mask_flags	= MTD_WRITEABLE, /* force read-only */
-	}, {
-		/* U-Boot environment */
-		.name		= "params",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 1 * NAND_BLOCK_SIZE,
-		.mask_flags	= 0,
-	}, {
-		/* Kernel */
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= SZ_4M,
-		.mask_flags	= 0,
-	}, {
-		/* File System */
-		.name		= "filesystem",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-		.mask_flags	= 0,
-	}
-	/* A few blocks at end hold a flash Bad Block Table. */
-};
-
-static struct davinci_nand_pdata davinci_ntosd2_nandflash_data = {
-	.core_chipsel	= 0,
-	.parts		= davinci_ntosd2_nandflash_partition,
-	.nr_parts	= ARRAY_SIZE(davinci_ntosd2_nandflash_partition),
-	.engine_type	= NAND_ECC_ENGINE_TYPE_ON_HOST,
-	.ecc_bits	= 1,
-	.bbt_options	= NAND_BBT_USE_FLASH,
-};
-
-static struct resource davinci_ntosd2_nandflash_resource[] = {
-	{
-		.start		= DM644X_ASYNC_EMIF_DATA_CE0_BASE,
-		.end		= DM644X_ASYNC_EMIF_DATA_CE0_BASE + SZ_16M - 1,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= DM644X_ASYNC_EMIF_CONTROL_BASE,
-		.end		= DM644X_ASYNC_EMIF_CONTROL_BASE + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device davinci_ntosd2_nandflash_device = {
-	.name		= "davinci_nand",
-	.id		= 0,
-	.dev		= {
-		.platform_data	= &davinci_ntosd2_nandflash_data,
-	},
-	.num_resources	= ARRAY_SIZE(davinci_ntosd2_nandflash_resource),
-	.resource	= davinci_ntosd2_nandflash_resource,
-};
-
-static u64 davinci_fb_dma_mask = DMA_BIT_MASK(32);
-
-static struct platform_device davinci_fb_device = {
-	.name		= "davincifb",
-	.id		= -1,
-	.dev = {
-		.dma_mask		= &davinci_fb_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-	.num_resources = 0,
-};
-
-static const struct gpio_led ntosd2_leds[] = {
-	{ .name = "led1_green", .gpio = 10, },
-	{ .name = "led1_red",   .gpio = 11, },
-	{ .name = "led2_green", .gpio = 12, },
-	{ .name = "led2_red",   .gpio = 13, },
-};
-
-static struct gpio_led_platform_data ntosd2_leds_data = {
-	.num_leds	= ARRAY_SIZE(ntosd2_leds),
-	.leds		= ntosd2_leds,
-};
-
-static struct platform_device ntosd2_leds_dev = {
-	.name = "leds-gpio",
-	.id   = -1,
-	.dev = {
-		.platform_data 		= &ntosd2_leds_data,
-	},
-};
-
-
-static struct platform_device *davinci_ntosd2_devices[] __initdata = {
-	&davinci_fb_device,
-	&ntosd2_leds_dev,
-};
-
-static void __init davinci_ntosd2_map_io(void)
-{
-	dm644x_init();
-}
-
-static struct davinci_mmc_config davinci_ntosd2_mmc_config = {
-	.wires		= 4,
-};
-
-#define HAS_ATA		(IS_ENABLED(CONFIG_BLK_DEV_PALMCHIP_BK3710) || \
-			 IS_ENABLED(CONFIG_PATA_BK3710))
-
-#define HAS_NAND	IS_ENABLED(CONFIG_MTD_NAND_DAVINCI)
-
-static __init void davinci_ntosd2_init(void)
-{
-	int ret;
-	struct clk *aemif_clk;
-	struct davinci_soc_info *soc_info = &davinci_soc_info;
-
-	dm644x_register_clocks();
-
-	dm644x_init_devices();
-
-	ret = dm644x_gpio_register();
-	if (ret)
-		pr_warn("%s: GPIO init failed: %d\n", __func__, ret);
-
-	aemif_clk = clk_get(NULL, "aemif");
-	clk_prepare_enable(aemif_clk);
-
-	if (HAS_ATA) {
-		if (HAS_NAND)
-			pr_warn("WARNING: both IDE and Flash are enabled, but they share AEMIF pins\n"
-				"\tDisable IDE for NAND/NOR support\n");
-		davinci_init_ide();
-	} else if (HAS_NAND) {
-		davinci_cfg_reg(DM644X_HPIEN_DISABLE);
-		davinci_cfg_reg(DM644X_ATAEN_DISABLE);
-
-		/* only one device will be jumpered and detected */
-		if (HAS_NAND)
-			platform_device_register(
-					&davinci_ntosd2_nandflash_device);
-	}
-
-	platform_add_devices(davinci_ntosd2_devices,
-				ARRAY_SIZE(davinci_ntosd2_devices));
-
-	davinci_serial_init(dm644x_serial_device);
-	dm644x_init_asp();
-
-	soc_info->emac_pdata->phy_id = NEUROS_OSD2_PHY_ID;
-
-	davinci_setup_usb(1000, 8);
-	/*
-	 * Mux the pins to be GPIOs, VLYNQEN is already done at startup.
-	 * The AEAWx are five new AEAW pins that can be muxed by separately.
-	 * They are a bitmask for GPIO management. According TI
-	 * documentation (https://www.ti.com/lit/gpn/tms320dm6446) to employ
-	 * gpio(10,11,12,13) for leds any combination of bits works except
-	 * four last. So we are to reset all five.
-	 */
-	davinci_cfg_reg(DM644X_AEAW0);
-	davinci_cfg_reg(DM644X_AEAW1);
-	davinci_cfg_reg(DM644X_AEAW2);
-	davinci_cfg_reg(DM644X_AEAW3);
-	davinci_cfg_reg(DM644X_AEAW4);
-
-	davinci_setup_mmc(0, &davinci_ntosd2_mmc_config);
-}
-
-MACHINE_START(NEUROS_OSD2, "Neuros OSD2")
-	/* Maintainer: Neuros Technologies <neuros@groups.google.com> */
-	.atag_offset	= 0x100,
-	.map_io		 = davinci_ntosd2_map_io,
-	.init_irq	= dm644x_init_irq,
-	.init_time	= dm644x_init_time,
-	.init_machine = davinci_ntosd2_init,
-	.init_late	= davinci_init_late,
-	.dma_zone_size	= SZ_128M,
-MACHINE_END
diff --git a/arch/arm/mach-davinci/board-sffsdr.c b/arch/arm/mach-davinci/board-sffsdr.c
deleted file mode 100644
index e87fd8f82d89..000000000000
--- a/arch/arm/mach-davinci/board-sffsdr.c
+++ /dev/null
@@ -1,151 +0,0 @@
-// SPDX-License-Identifier: GPL-2.0-or-later
-/*
- * Lyrtech SFFSDR board support.
- *
- * Copyright (C) 2008 Philip Balister, OpenSDR <philip@opensdr.com>
- * Copyright (C) 2008 Lyrtech <www.lyrtech.com>
- *
- * Based on DV-EVM platform, original copyright follows:
- *
- * Copyright (C) 2007 MontaVista Software, Inc.
- */
-
-#include <linux/init.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/property.h>
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/rawnand.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-#include <asm/mach/flash.h>
-
-#include <linux/platform_data/i2c-davinci.h>
-#include <linux/platform_data/usb-davinci.h>
-
-#include "common.h"
-#include "serial.h"
-#include "mux.h"
-#include "davinci.h"
-
-#define SFFSDR_PHY_ID		"davinci_mdio-0:01"
-static struct mtd_partition davinci_sffsdr_nandflash_partition[] = {
-	/* U-Boot Environment: Block 0
-	 * UBL:                Block 1
-	 * U-Boot:             Blocks 6-7 (256 kb)
-	 * Integrity Kernel:   Blocks 8-31 (3 Mb)
-	 * Integrity Data:     Blocks 100-END
-	 */
-	{
-		.name		= "Linux Kernel",
-		.offset		= 32 * SZ_128K,
-		.size		= 16 * SZ_128K, /* 2 Mb */
-		.mask_flags	= MTD_WRITEABLE, /* Force read-only */
-	},
-	{
-		.name		= "Linux ROOT",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 256 * SZ_128K, /* 32 Mb */
-		.mask_flags	= 0, /* R/W */
-	},
-};
-
-static struct flash_platform_data davinci_sffsdr_nandflash_data = {
-	.parts		= davinci_sffsdr_nandflash_partition,
-	.nr_parts	= ARRAY_SIZE(davinci_sffsdr_nandflash_partition),
-};
-
-static struct resource davinci_sffsdr_nandflash_resource[] = {
-	{
-		.start		= DM644X_ASYNC_EMIF_DATA_CE0_BASE,
-		.end		= DM644X_ASYNC_EMIF_DATA_CE0_BASE + SZ_16M - 1,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= DM644X_ASYNC_EMIF_CONTROL_BASE,
-		.end		= DM644X_ASYNC_EMIF_CONTROL_BASE + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device davinci_sffsdr_nandflash_device = {
-	.name		= "davinci_nand", /* Name of driver */
-	.id		= 0,
-	.dev		= {
-		.platform_data	= &davinci_sffsdr_nandflash_data,
-	},
-	.num_resources	= ARRAY_SIZE(davinci_sffsdr_nandflash_resource),
-	.resource	= davinci_sffsdr_nandflash_resource,
-};
-
-static const struct property_entry eeprom_properties[] = {
-	PROPERTY_ENTRY_U32("pagesize", 32),
-	{ }
-};
-
-static const struct software_node eeprom_node = {
-	.properties = eeprom_properties,
-};
-
-static struct i2c_board_info __initdata i2c_info[] =  {
-	{
-		I2C_BOARD_INFO("24c64", 0x50),
-		.swnode = &eeprom_node,
-	},
-	/* Other I2C devices:
-	 * MSP430,  addr 0x23 (not used)
-	 * PCA9543, addr 0x70 (setup done by U-Boot)
-	 * ADS7828, addr 0x48 (ADC for voltage monitoring.)
-	 */
-};
-
-static struct davinci_i2c_platform_data i2c_pdata = {
-	.bus_freq	= 20 /* kHz */,
-	.bus_delay	= 100 /* usec */,
-};
-
-static void __init sffsdr_init_i2c(void)
-{
-	davinci_init_i2c(&i2c_pdata);
-	i2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));
-}
-
-static struct platform_device *davinci_sffsdr_devices[] __initdata = {
-	&davinci_sffsdr_nandflash_device,
-};
-
-static void __init davinci_sffsdr_map_io(void)
-{
-	dm644x_init();
-}
-
-static __init void davinci_sffsdr_init(void)
-{
-	struct davinci_soc_info *soc_info = &davinci_soc_info;
-
-	dm644x_register_clocks();
-
-	dm644x_init_devices();
-
-	platform_add_devices(davinci_sffsdr_devices,
-			     ARRAY_SIZE(davinci_sffsdr_devices));
-	sffsdr_init_i2c();
-	davinci_serial_init(dm644x_serial_device);
-	soc_info->emac_pdata->phy_id = SFFSDR_PHY_ID;
-	davinci_setup_usb(0, 0); /* We support only peripheral mode. */
-
-	/* mux VLYNQ pins */
-	davinci_cfg_reg(DM644X_VLYNQEN);
-	davinci_cfg_reg(DM644X_VLYNQWD);
-}
-
-MACHINE_START(SFFSDR, "Lyrtech SFFSDR")
-	.atag_offset  = 0x100,
-	.map_io	      = davinci_sffsdr_map_io,
-	.init_irq     = dm644x_init_irq,
-	.init_time	= dm644x_init_time,
-	.init_machine = davinci_sffsdr_init,
-	.init_late	= davinci_init_late,
-	.dma_zone_size	= SZ_128M,
-MACHINE_END
diff --git a/arch/arm/mach-davinci/dm644x.c b/arch/arm/mach-davinci/dm644x.c
deleted file mode 100644
index 1ce48d0fb16d..000000000000
--- a/arch/arm/mach-davinci/dm644x.c
+++ /dev/null
@@ -1,765 +0,0 @@
-/*
- * TI DaVinci DM644x chip specific setup
- *
- * Author: Kevin Hilman, Deep Root Systems, LLC
- *
- * 2007 (c) Deep Root Systems, LLC. This file is licensed under
- * the terms of the GNU General Public License version 2. This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/clk/davinci.h>
-#include <linux/clkdev.h>
-#include <linux/dmaengine.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/irqchip/irq-davinci-aintc.h>
-#include <linux/platform_data/edma.h>
-#include <linux/platform_data/gpio-davinci.h>
-#include <linux/platform_device.h>
-#include <linux/serial_8250.h>
-
-#include <clocksource/timer-davinci.h>
-
-#include <asm/mach/map.h>
-
-#include "common.h"
-#include "cputype.h"
-#include "serial.h"
-#include "asp.h"
-#include "davinci.h"
-#include "irqs.h"
-#include "mux.h"
-
-/*
- * Device specific clocks
- */
-#define DM644X_REF_FREQ		27000000
-
-#define DM644X_EMAC_BASE		0x01c80000
-#define DM644X_EMAC_MDIO_BASE		(DM644X_EMAC_BASE + 0x4000)
-#define DM644X_EMAC_CNTRL_OFFSET	0x0000
-#define DM644X_EMAC_CNTRL_MOD_OFFSET	0x1000
-#define DM644X_EMAC_CNTRL_RAM_OFFSET	0x2000
-#define DM644X_EMAC_CNTRL_RAM_SIZE	0x2000
-
-static struct emac_platform_data dm644x_emac_pdata = {
-	.ctrl_reg_offset	= DM644X_EMAC_CNTRL_OFFSET,
-	.ctrl_mod_reg_offset	= DM644X_EMAC_CNTRL_MOD_OFFSET,
-	.ctrl_ram_offset	= DM644X_EMAC_CNTRL_RAM_OFFSET,
-	.ctrl_ram_size		= DM644X_EMAC_CNTRL_RAM_SIZE,
-	.version		= EMAC_VERSION_1,
-};
-
-static struct resource dm644x_emac_resources[] = {
-	{
-		.start	= DM644X_EMAC_BASE,
-		.end	= DM644X_EMAC_BASE + SZ_16K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start = DAVINCI_INTC_IRQ(IRQ_EMACINT),
-		.end   = DAVINCI_INTC_IRQ(IRQ_EMACINT),
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device dm644x_emac_device = {
-       .name		= "davinci_emac",
-       .id		= 1,
-       .dev = {
-	       .platform_data	= &dm644x_emac_pdata,
-       },
-       .num_resources	= ARRAY_SIZE(dm644x_emac_resources),
-       .resource	= dm644x_emac_resources,
-};
-
-static struct resource dm644x_mdio_resources[] = {
-	{
-		.start	= DM644X_EMAC_MDIO_BASE,
-		.end	= DM644X_EMAC_MDIO_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device dm644x_mdio_device = {
-	.name		= "davinci_mdio",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(dm644x_mdio_resources),
-	.resource	= dm644x_mdio_resources,
-};
-
-/*
- * Device specific mux setup
- *
- *	soc	description	mux  mode   mode  mux	 dbg
- *				reg  offset mask  mode
- */
-static const struct mux_config dm644x_pins[] = {
-#ifdef CONFIG_DAVINCI_MUX
-MUX_CFG(DM644X, HDIREN,		0,   16,    1,	  1,	 true)
-MUX_CFG(DM644X, ATAEN,		0,   17,    1,	  1,	 true)
-MUX_CFG(DM644X, ATAEN_DISABLE,	0,   17,    1,	  0,	 true)
-
-MUX_CFG(DM644X, HPIEN_DISABLE,	0,   29,    1,	  0,	 true)
-
-MUX_CFG(DM644X, AEAW,		0,   0,     31,	  31,	 true)
-MUX_CFG(DM644X, AEAW0,		0,   0,     1,	  0,	 true)
-MUX_CFG(DM644X, AEAW1,		0,   1,     1,	  0,	 true)
-MUX_CFG(DM644X, AEAW2,		0,   2,     1,	  0,	 true)
-MUX_CFG(DM644X, AEAW3,		0,   3,     1,	  0,	 true)
-MUX_CFG(DM644X, AEAW4,		0,   4,     1,	  0,	 true)
-
-MUX_CFG(DM644X, MSTK,		1,   9,     1,	  0,	 false)
-
-MUX_CFG(DM644X, I2C,		1,   7,     1,	  1,	 false)
-
-MUX_CFG(DM644X, MCBSP,		1,   10,    1,	  1,	 false)
-
-MUX_CFG(DM644X, UART1,		1,   1,     1,	  1,	 true)
-MUX_CFG(DM644X, UART2,		1,   2,     1,	  1,	 true)
-
-MUX_CFG(DM644X, PWM0,		1,   4,     1,	  1,	 false)
-
-MUX_CFG(DM644X, PWM1,		1,   5,     1,	  1,	 false)
-
-MUX_CFG(DM644X, PWM2,		1,   6,     1,	  1,	 false)
-
-MUX_CFG(DM644X, VLYNQEN,	0,   15,    1,	  1,	 false)
-MUX_CFG(DM644X, VLSCREN,	0,   14,    1,	  1,	 false)
-MUX_CFG(DM644X, VLYNQWD,	0,   12,    3,	  3,	 false)
-
-MUX_CFG(DM644X, EMACEN,		0,   31,    1,	  1,	 true)
-
-MUX_CFG(DM644X, GPIO3V,		0,   31,    1,	  0,	 true)
-
-MUX_CFG(DM644X, GPIO0,		0,   24,    1,	  0,	 true)
-MUX_CFG(DM644X, GPIO3,		0,   25,    1,	  0,	 false)
-MUX_CFG(DM644X, GPIO43_44,	1,   7,     1,	  0,	 false)
-MUX_CFG(DM644X, GPIO46_47,	0,   22,    1,	  0,	 true)
-
-MUX_CFG(DM644X, RGB666,		0,   22,    1,	  1,	 true)
-
-MUX_CFG(DM644X, LOEEN,		0,   24,    1,	  1,	 true)
-MUX_CFG(DM644X, LFLDEN,		0,   25,    1,	  1,	 false)
-#endif
-};
-
-/* FIQ are pri 0-1; otherwise 2-7, with 7 lowest priority */
-static u8 dm644x_default_priorities[DAVINCI_N_AINTC_IRQ] = {
-	[IRQ_VDINT0]		= 2,
-	[IRQ_VDINT1]		= 6,
-	[IRQ_VDINT2]		= 6,
-	[IRQ_HISTINT]		= 6,
-	[IRQ_H3AINT]		= 6,
-	[IRQ_PRVUINT]		= 6,
-	[IRQ_RSZINT]		= 6,
-	[7]			= 7,
-	[IRQ_VENCINT]		= 6,
-	[IRQ_ASQINT]		= 6,
-	[IRQ_IMXINT]		= 6,
-	[IRQ_VLCDINT]		= 6,
-	[IRQ_USBINT]		= 4,
-	[IRQ_EMACINT]		= 4,
-	[14]			= 7,
-	[15]			= 7,
-	[IRQ_CCINT0]		= 5,	/* dma */
-	[IRQ_CCERRINT]		= 5,	/* dma */
-	[IRQ_TCERRINT0]		= 5,	/* dma */
-	[IRQ_TCERRINT]		= 5,	/* dma */
-	[IRQ_PSCIN]		= 7,
-	[21]			= 7,
-	[IRQ_IDE]		= 4,
-	[23]			= 7,
-	[IRQ_MBXINT]		= 7,
-	[IRQ_MBRINT]		= 7,
-	[IRQ_MMCINT]		= 7,
-	[IRQ_SDIOINT]		= 7,
-	[28]			= 7,
-	[IRQ_DDRINT]		= 7,
-	[IRQ_AEMIFINT]		= 7,
-	[IRQ_VLQINT]		= 4,
-	[IRQ_TINT0_TINT12]	= 2,	/* clockevent */
-	[IRQ_TINT0_TINT34]	= 2,	/* clocksource */
-	[IRQ_TINT1_TINT12]	= 7,	/* DSP timer */
-	[IRQ_TINT1_TINT34]	= 7,	/* system tick */
-	[IRQ_PWMINT0]		= 7,
-	[IRQ_PWMINT1]		= 7,
-	[IRQ_PWMINT2]		= 7,
-	[IRQ_I2C]		= 3,
-	[IRQ_UARTINT0]		= 3,
-	[IRQ_UARTINT1]		= 3,
-	[IRQ_UARTINT2]		= 3,
-	[IRQ_SPINT0]		= 3,
-	[IRQ_SPINT1]		= 3,
-	[45]			= 7,
-	[IRQ_DSP2ARM0]		= 4,
-	[IRQ_DSP2ARM1]		= 4,
-	[IRQ_GPIO0]		= 7,
-	[IRQ_GPIO1]		= 7,
-	[IRQ_GPIO2]		= 7,
-	[IRQ_GPIO3]		= 7,
-	[IRQ_GPIO4]		= 7,
-	[IRQ_GPIO5]		= 7,
-	[IRQ_GPIO6]		= 7,
-	[IRQ_GPIO7]		= 7,
-	[IRQ_GPIOBNK0]		= 7,
-	[IRQ_GPIOBNK1]		= 7,
-	[IRQ_GPIOBNK2]		= 7,
-	[IRQ_GPIOBNK3]		= 7,
-	[IRQ_GPIOBNK4]		= 7,
-	[IRQ_COMMTX]		= 7,
-	[IRQ_COMMRX]		= 7,
-	[IRQ_EMUINT]		= 7,
-};
-
-/*----------------------------------------------------------------------*/
-
-static s8 queue_priority_mapping[][2] = {
-	/* {event queue no, Priority} */
-	{0, 3},
-	{1, 7},
-	{-1, -1},
-};
-
-static const struct dma_slave_map dm644x_edma_map[] = {
-	{ "davinci-mcbsp", "tx", EDMA_FILTER_PARAM(0, 2) },
-	{ "davinci-mcbsp", "rx", EDMA_FILTER_PARAM(0, 3) },
-	{ "spi_davinci", "tx", EDMA_FILTER_PARAM(0, 16) },
-	{ "spi_davinci", "rx", EDMA_FILTER_PARAM(0, 17) },
-	{ "dm6441-mmc.0", "rx", EDMA_FILTER_PARAM(0, 26) },
-	{ "dm6441-mmc.0", "tx", EDMA_FILTER_PARAM(0, 27) },
-};
-
-static struct edma_soc_info dm644x_edma_pdata = {
-	.queue_priority_mapping	= queue_priority_mapping,
-	.default_queue		= EVENTQ_1,
-	.slave_map		= dm644x_edma_map,
-	.slavecnt		= ARRAY_SIZE(dm644x_edma_map),
-};
-
-static struct resource edma_resources[] = {
-	{
-		.name	= "edma3_cc",
-		.start	= 0x01c00000,
-		.end	= 0x01c00000 + SZ_64K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "edma3_tc0",
-		.start	= 0x01c10000,
-		.end	= 0x01c10000 + SZ_1K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "edma3_tc1",
-		.start	= 0x01c10400,
-		.end	= 0x01c10400 + SZ_1K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "edma3_ccint",
-		.start	= DAVINCI_INTC_IRQ(IRQ_CCINT0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.name	= "edma3_ccerrint",
-		.start	= DAVINCI_INTC_IRQ(IRQ_CCERRINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-	/* not using TC*_ERR */
-};
-
-static const struct platform_device_info dm644x_edma_device __initconst = {
-	.name		= "edma",
-	.id		= 0,
-	.dma_mask	= DMA_BIT_MASK(32),
-	.res		= edma_resources,
-	.num_res	= ARRAY_SIZE(edma_resources),
-	.data		= &dm644x_edma_pdata,
-	.size_data	= sizeof(dm644x_edma_pdata),
-};
-
-/* DM6446 EVM uses ASP0; line-out is a pair of RCA jacks */
-static struct resource dm644x_asp_resources[] = {
-	{
-		.name	= "mpu",
-		.start	= DAVINCI_ASP0_BASE,
-		.end	= DAVINCI_ASP0_BASE + SZ_8K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= DAVINCI_DMA_ASP0_TX,
-		.end	= DAVINCI_DMA_ASP0_TX,
-		.flags	= IORESOURCE_DMA,
-	},
-	{
-		.start	= DAVINCI_DMA_ASP0_RX,
-		.end	= DAVINCI_DMA_ASP0_RX,
-		.flags	= IORESOURCE_DMA,
-	},
-};
-
-static struct platform_device dm644x_asp_device = {
-	.name		= "davinci-mcbsp",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(dm644x_asp_resources),
-	.resource	= dm644x_asp_resources,
-};
-
-#define DM644X_VPSS_BASE	0x01c73400
-
-static struct resource dm644x_vpss_resources[] = {
-	{
-		/* VPSS Base address */
-		.name		= "vpss",
-		.start		= DM644X_VPSS_BASE,
-		.end		= DM644X_VPSS_BASE + 0xff,
-		.flags		= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device dm644x_vpss_device = {
-	.name			= "vpss",
-	.id			= -1,
-	.dev.platform_data	= "dm644x_vpss",
-	.num_resources		= ARRAY_SIZE(dm644x_vpss_resources),
-	.resource		= dm644x_vpss_resources,
-};
-
-static struct resource dm644x_vpfe_resources[] = {
-	{
-		.start          = DAVINCI_INTC_IRQ(IRQ_VDINT0),
-		.end            = DAVINCI_INTC_IRQ(IRQ_VDINT0),
-		.flags          = IORESOURCE_IRQ,
-	},
-	{
-		.start          = DAVINCI_INTC_IRQ(IRQ_VDINT1),
-		.end            = DAVINCI_INTC_IRQ(IRQ_VDINT1),
-		.flags          = IORESOURCE_IRQ,
-	},
-};
-
-static u64 dm644x_video_dma_mask = DMA_BIT_MASK(32);
-static struct resource dm644x_ccdc_resource[] = {
-	/* CCDC Base address */
-	{
-		.start          = 0x01c70400,
-		.end            = 0x01c70400 + 0xff,
-		.flags          = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device dm644x_ccdc_dev = {
-	.name           = "dm644x_ccdc",
-	.id             = -1,
-	.num_resources  = ARRAY_SIZE(dm644x_ccdc_resource),
-	.resource       = dm644x_ccdc_resource,
-	.dev = {
-		.dma_mask               = &dm644x_video_dma_mask,
-		.coherent_dma_mask      = DMA_BIT_MASK(32),
-	},
-};
-
-static struct platform_device dm644x_vpfe_dev = {
-	.name		= CAPTURE_DRV_NAME,
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(dm644x_vpfe_resources),
-	.resource	= dm644x_vpfe_resources,
-	.dev = {
-		.dma_mask		= &dm644x_video_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-};
-
-#define DM644X_OSD_BASE		0x01c72600
-
-static struct resource dm644x_osd_resources[] = {
-	{
-		.start	= DM644X_OSD_BASE,
-		.end	= DM644X_OSD_BASE + 0x1ff,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device dm644x_osd_dev = {
-	.name		= DM644X_VPBE_OSD_SUBDEV_NAME,
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(dm644x_osd_resources),
-	.resource	= dm644x_osd_resources,
-	.dev		= {
-		.dma_mask		= &dm644x_video_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-};
-
-#define DM644X_VENC_BASE		0x01c72400
-
-static struct resource dm644x_venc_resources[] = {
-	{
-		.start	= DM644X_VENC_BASE,
-		.end	= DM644X_VENC_BASE + 0x17f,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-#define DM644X_VPSS_MUXSEL_PLL2_MODE          BIT(0)
-#define DM644X_VPSS_MUXSEL_VPBECLK_MODE       BIT(1)
-#define DM644X_VPSS_VENCLKEN                  BIT(3)
-#define DM644X_VPSS_DACCLKEN                  BIT(4)
-
-static int dm644x_venc_setup_clock(enum vpbe_enc_timings_type type,
-				   unsigned int pclock)
-{
-	int ret = 0;
-	u32 v = DM644X_VPSS_VENCLKEN;
-
-	switch (type) {
-	case VPBE_ENC_STD:
-		v |= DM644X_VPSS_DACCLKEN;
-		writel(v, DAVINCI_SYSMOD_VIRT(SYSMOD_VPSS_CLKCTL));
-		break;
-	case VPBE_ENC_DV_TIMINGS:
-		if (pclock <= 27000000) {
-			v |= DM644X_VPSS_DACCLKEN;
-			writel(v, DAVINCI_SYSMOD_VIRT(SYSMOD_VPSS_CLKCTL));
-		} else {
-			/*
-			 * For HD, use external clock source since
-			 * HD requires higher clock rate
-			 */
-			v |= DM644X_VPSS_MUXSEL_VPBECLK_MODE;
-			writel(v, DAVINCI_SYSMOD_VIRT(SYSMOD_VPSS_CLKCTL));
-		}
-		break;
-	default:
-		ret  = -EINVAL;
-	}
-
-	return ret;
-}
-
-static struct resource dm644x_v4l2_disp_resources[] = {
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_VENCINT),
-		.end	= DAVINCI_INTC_IRQ(IRQ_VENCINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device dm644x_vpbe_display = {
-	.name		= "vpbe-v4l2",
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(dm644x_v4l2_disp_resources),
-	.resource	= dm644x_v4l2_disp_resources,
-	.dev		= {
-		.dma_mask		= &dm644x_video_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-};
-
-static struct venc_platform_data dm644x_venc_pdata = {
-	.setup_clock	= dm644x_venc_setup_clock,
-};
-
-static struct platform_device dm644x_venc_dev = {
-	.name		= DM644X_VPBE_VENC_SUBDEV_NAME,
-	.id		= -1,
-	.num_resources	= ARRAY_SIZE(dm644x_venc_resources),
-	.resource	= dm644x_venc_resources,
-	.dev		= {
-		.dma_mask		= &dm644x_video_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-		.platform_data		= &dm644x_venc_pdata,
-	},
-};
-
-static struct platform_device dm644x_vpbe_dev = {
-	.name		= "vpbe_controller",
-	.id		= -1,
-	.dev		= {
-		.dma_mask		= &dm644x_video_dma_mask,
-		.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-};
-
-static struct resource dm644_gpio_resources[] = {
-	{	/* registers */
-		.start	= DAVINCI_GPIO_BASE,
-		.end	= DAVINCI_GPIO_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{	/* interrupt */
-		.start	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK0),
-		.end	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK1),
-		.end	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK1),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK2),
-		.end	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK2),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK3),
-		.end	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK3),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK4),
-		.end	= DAVINCI_INTC_IRQ(IRQ_GPIOBNK4),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct davinci_gpio_platform_data dm644_gpio_platform_data = {
-	.no_auto_base	= true,
-	.base		= 0,
-	.ngpio		= 71,
-};
-
-int __init dm644x_gpio_register(void)
-{
-	return davinci_gpio_register(dm644_gpio_resources,
-				     ARRAY_SIZE(dm644_gpio_resources),
-				     &dm644_gpio_platform_data);
-}
-/*----------------------------------------------------------------------*/
-
-static struct map_desc dm644x_io_desc[] = {
-	{
-		.virtual	= IO_VIRT,
-		.pfn		= __phys_to_pfn(IO_PHYS),
-		.length		= IO_SIZE,
-		.type		= MT_DEVICE
-	},
-};
-
-/* Contents of JTAG ID register used to identify exact cpu type */
-static struct davinci_id dm644x_ids[] = {
-	{
-		.variant	= 0x0,
-		.part_no	= 0xb700,
-		.manufacturer	= 0x017,
-		.cpu_id		= DAVINCI_CPU_ID_DM6446,
-		.name		= "dm6446",
-	},
-	{
-		.variant	= 0x1,
-		.part_no	= 0xb700,
-		.manufacturer	= 0x017,
-		.cpu_id		= DAVINCI_CPU_ID_DM6446,
-		.name		= "dm6446a",
-	},
-};
-
-/*
- * Bottom half of timer0 is used for clockevent, top half is used for
- * clocksource.
- */
-static const struct davinci_timer_cfg dm644x_timer_cfg = {
-	.reg = DEFINE_RES_IO(DAVINCI_TIMER0_BASE, SZ_4K),
-	.irq = {
-		DEFINE_RES_IRQ(DAVINCI_INTC_IRQ(IRQ_TINT0_TINT12)),
-		DEFINE_RES_IRQ(DAVINCI_INTC_IRQ(IRQ_TINT0_TINT34)),
-	},
-};
-
-static struct plat_serial8250_port dm644x_serial0_platform_data[] = {
-	{
-		.mapbase	= DAVINCI_UART0_BASE,
-		.irq		= DAVINCI_INTC_IRQ(IRQ_UARTINT0),
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-	},
-	{
-		.flags	= 0,
-	}
-};
-static struct plat_serial8250_port dm644x_serial1_platform_data[] = {
-	{
-		.mapbase	= DAVINCI_UART1_BASE,
-		.irq		= DAVINCI_INTC_IRQ(IRQ_UARTINT1),
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-	},
-	{
-		.flags	= 0,
-	}
-};
-static struct plat_serial8250_port dm644x_serial2_platform_data[] = {
-	{
-		.mapbase	= DAVINCI_UART2_BASE,
-		.irq		= DAVINCI_INTC_IRQ(IRQ_UARTINT2),
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM,
-		.regshift	= 2,
-	},
-	{
-		.flags	= 0,
-	}
-};
-
-struct platform_device dm644x_serial_device[] = {
-	{
-		.name			= "serial8250",
-		.id			= PLAT8250_DEV_PLATFORM,
-		.dev			= {
-			.platform_data	= dm644x_serial0_platform_data,
-		}
-	},
-	{
-		.name			= "serial8250",
-		.id			= PLAT8250_DEV_PLATFORM1,
-		.dev			= {
-			.platform_data	= dm644x_serial1_platform_data,
-		}
-	},
-	{
-		.name			= "serial8250",
-		.id			= PLAT8250_DEV_PLATFORM2,
-		.dev			= {
-			.platform_data	= dm644x_serial2_platform_data,
-		}
-	},
-	{
-	}
-};
-
-static const struct davinci_soc_info davinci_soc_info_dm644x = {
-	.io_desc		= dm644x_io_desc,
-	.io_desc_num		= ARRAY_SIZE(dm644x_io_desc),
-	.jtag_id_reg		= 0x01c40028,
-	.ids			= dm644x_ids,
-	.ids_num		= ARRAY_SIZE(dm644x_ids),
-	.pinmux_base		= DAVINCI_SYSTEM_MODULE_BASE,
-	.pinmux_pins		= dm644x_pins,
-	.pinmux_pins_num	= ARRAY_SIZE(dm644x_pins),
-	.emac_pdata		= &dm644x_emac_pdata,
-	.sram_dma		= 0x00008000,
-	.sram_len		= SZ_16K,
-};
-
-void __init dm644x_init_asp(void)
-{
-	davinci_cfg_reg(DM644X_MCBSP);
-	platform_device_register(&dm644x_asp_device);
-}
-
-void __init dm644x_init(void)
-{
-	davinci_common_init(&davinci_soc_info_dm644x);
-	davinci_map_sysmod();
-}
-
-void __init dm644x_init_time(void)
-{
-	void __iomem *pll1, *psc;
-	struct clk *clk;
-	int rv;
-
-	clk_register_fixed_rate(NULL, "ref_clk", NULL, 0, DM644X_REF_FREQ);
-
-	pll1 = ioremap(DAVINCI_PLL1_BASE, SZ_1K);
-	dm644x_pll1_init(NULL, pll1, NULL);
-
-	psc = ioremap(DAVINCI_PWR_SLEEP_CNTRL_BASE, SZ_4K);
-	dm644x_psc_init(NULL, psc);
-
-	clk = clk_get(NULL, "timer0");
-	if (WARN_ON(IS_ERR(clk))) {
-		pr_err("Unable to get the timer clock\n");
-		return;
-	}
-
-	rv = davinci_timer_register(clk, &dm644x_timer_cfg);
-	WARN(rv, "Unable to register the timer: %d\n", rv);
-}
-
-static struct resource dm644x_pll2_resources[] = {
-	{
-		.start	= DAVINCI_PLL2_BASE,
-		.end	= DAVINCI_PLL2_BASE + SZ_1K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device dm644x_pll2_device = {
-	.name		= "dm644x-pll2",
-	.id		= -1,
-	.resource	= dm644x_pll2_resources,
-	.num_resources	= ARRAY_SIZE(dm644x_pll2_resources),
-};
-
-void __init dm644x_register_clocks(void)
-{
-	/* PLL1 and PSC are registered in dm644x_init_time() */
-	platform_device_register(&dm644x_pll2_device);
-}
-
-int __init dm644x_init_video(struct vpfe_config *vpfe_cfg,
-				struct vpbe_config *vpbe_cfg)
-{
-	if (vpfe_cfg || vpbe_cfg)
-		platform_device_register(&dm644x_vpss_device);
-
-	if (vpfe_cfg) {
-		dm644x_vpfe_dev.dev.platform_data = vpfe_cfg;
-		platform_device_register(&dm644x_ccdc_dev);
-		platform_device_register(&dm644x_vpfe_dev);
-	}
-
-	if (vpbe_cfg) {
-		dm644x_vpbe_dev.dev.platform_data = vpbe_cfg;
-		platform_device_register(&dm644x_osd_dev);
-		platform_device_register(&dm644x_venc_dev);
-		platform_device_register(&dm644x_vpbe_dev);
-		platform_device_register(&dm644x_vpbe_display);
-	}
-
-	return 0;
-}
-
-static const struct davinci_aintc_config dm644x_aintc_config = {
-	.reg = {
-		.start		= DAVINCI_ARM_INTC_BASE,
-		.end		= DAVINCI_ARM_INTC_BASE + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	.num_irqs		= 64,
-	.prios			= dm644x_default_priorities,
-};
-
-void __init dm644x_init_irq(void)
-{
-	davinci_aintc_init(&dm644x_aintc_config);
-}
-
-void __init dm644x_init_devices(void)
-{
-	struct platform_device *edma_pdev;
-	int ret;
-
-	edma_pdev = platform_device_register_full(&dm644x_edma_device);
-	if (IS_ERR(edma_pdev))
-		pr_warn("%s: Failed to register eDMA\n", __func__);
-
-	platform_device_register(&dm644x_mdio_device);
-	platform_device_register(&dm644x_emac_device);
-
-	ret = davinci_init_wdt();
-	if (ret)
-		pr_warn("%s: watchdog init failed: %d\n", __func__, ret);
-
-}
-- 
2.36.1

