Return-Path: <linux-gpio-owner@vger.kernel.org>
X-Original-To: lists+linux-gpio@lfdr.de
Delivered-To: lists+linux-gpio@lfdr.de
Received: from out1.vger.email (out1.vger.email [IPv6:2620:137:e000::1:20])
	by mail.lfdr.de (Postfix) with ESMTP id 3EEB9563349
	for <lists+linux-gpio@lfdr.de>; Fri,  1 Jul 2022 14:13:17 +0200 (CEST)
Received: (majordomo@vger.kernel.org) by vger.kernel.org via listexpand
        id S236201AbiGAMNM (ORCPT <rfc822;lists+linux-gpio@lfdr.de>);
        Fri, 1 Jul 2022 08:13:12 -0400
Received: from lindbergh.monkeyblade.net ([23.128.96.19]:46742 "EHLO
        lindbergh.monkeyblade.net" rhost-flags-OK-OK-OK-OK) by vger.kernel.org
        with ESMTP id S234291AbiGAMNL (ORCPT
        <rfc822;linux-gpio@vger.kernel.org>); Fri, 1 Jul 2022 08:13:11 -0400
Received: from mail-lj1-x22c.google.com (mail-lj1-x22c.google.com [IPv6:2a00:1450:4864:20::22c])
        by lindbergh.monkeyblade.net (Postfix) with ESMTPS id C0F4BEAC
        for <linux-gpio@vger.kernel.org>; Fri,  1 Jul 2022 05:13:07 -0700 (PDT)
Received: by mail-lj1-x22c.google.com with SMTP id a39so2357762ljq.11
        for <linux-gpio@vger.kernel.org>; Fri, 01 Jul 2022 05:13:07 -0700 (PDT)
DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=linaro.org; s=google;
        h=from:to:cc:subject:date:message-id:mime-version
         :content-transfer-encoding;
        bh=D/1QDj0Nxj+niNSALI0gBl3QxuF/2nRINdLbcvA6TpI=;
        b=MlofWfUvbeAaeYVMEErLv9usTmw0yMig4m0z6MwOXW2ukg8FhGIv03NUw5hX9ki/Jz
         AheFbAns1s5eJcmB8ZAF1wZyrh5wO1GYeoo+av6/fxt73tMw0eLt3dmbOmCfXN3/qLk6
         ArsEj6+eH7ZfuVd7eQeWHz+8W/JwZ102Si6mREkrgflD5wWF7KV30ncs8KqhcHx6rJUr
         pHd9nQIpKdoL0RZJu4EE7vG2oVn/9YjTGG8P9+OttC4/PZhXWvV0t7QPkn2NpnbGnvVR
         M0NKGrn5jEVIaRrCygqJJ7wglFhLXfnzc8+hfdAZfvOL+1y5q03v0Nw5wwz9bbq9jSdn
         5nwQ==
X-Google-DKIM-Signature: v=1; a=rsa-sha256; c=relaxed/relaxed;
        d=1e100.net; s=20210112;
        h=x-gm-message-state:from:to:cc:subject:date:message-id:mime-version
         :content-transfer-encoding;
        bh=D/1QDj0Nxj+niNSALI0gBl3QxuF/2nRINdLbcvA6TpI=;
        b=u4iGCbWBW9l4w4VArBS9GoU4ZH75DNrAbKUaJAnVchWNvlPR1MLI16dVA4WbsTv15o
         Miyca+4y8WSBVSgkGl4zAE4DQnyQbN6JX02rLsSpSfAZGkjMoQe4ThFqKamEtvrbtSpk
         pQffzFQ+rVj47069S8hfvIATPRHC232wEKVj30QfZ+wflAx0FMDPJOzMcpqi3aOYRocO
         KmOaMRCL+pkOmA+8Q+ZTyTAwMxpMUJEtVaWs23Y8VA9HX3qDd8eW/igqwUu19wvZXqDV
         OCy4qhmb0ixbLgRE0RNnRSy4YXdc6LzIlpJvzac8KhT9CpBkmgQ84ecL8YdygkbBWLgU
         1tbA==
X-Gm-Message-State: AJIora+y8ePJZsvSwFXp0vhK9+0GGa+gHaUxvt64LgfjmQByl44SrVP9
        ohU2aQiezC53yfEgfMZSHXDwmA==
X-Google-Smtp-Source: AGRyM1sUoPiEez2JQIr1ksOPN0lNqduBkBszWQKpcMTM1zqoSxy7VbxvMxHT80VngbKDClBrXhRdkw==
X-Received: by 2002:a2e:a16f:0:b0:25a:7527:95ce with SMTP id u15-20020a2ea16f000000b0025a752795cemr7749976ljl.305.1656677585912;
        Fri, 01 Jul 2022 05:13:05 -0700 (PDT)
Received: from localhost.localdomain (c-fdcc225c.014-348-6c756e10.bbcust.telenor.se. [92.34.204.253])
        by smtp.gmail.com with ESMTPSA id a23-20020a056512201700b0048162b71f9fsm143200lfb.301.2022.07.01.05.13.05
        (version=TLS1_3 cipher=TLS_AES_256_GCM_SHA384 bits=256/256);
        Fri, 01 Jul 2022 05:13:05 -0700 (PDT)
From:   Linus Walleij <linus.walleij@linaro.org>
To:     Sekhar Nori <nsekhar@ti.com>,
        Bartosz Golaszewski <bgolaszewski@baylibre.com>
Cc:     linux-arm-kernel@lists.infradead.org, linux-gpio@vger.kernel.org,
        Arnd Bergmann <arnd@kernel.org>,
        Linus Walleij <linus.walleij@linaro.org>,
        Kevin Hilman <khilman@baylibre.com>,
        Matt Porter <mporter@konsulko.com>
Subject: [PATCH] ARM: davinci: Delete DM646x board files
Date:   Fri,  1 Jul 2022 14:11:03 +0200
Message-Id: <20220701121103.780216-1-linus.walleij@linaro.org>
X-Mailer: git-send-email 2.36.1
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-Spam-Status: No, score=-2.1 required=5.0 tests=BAYES_00,DKIM_SIGNED,
        DKIM_VALID,DKIM_VALID_AU,DKIM_VALID_EF,RCVD_IN_DNSWL_NONE,
        SPF_HELO_NONE,SPF_PASS,T_SCC_BODY_TEXT_LINE autolearn=ham
        autolearn_force=no version=3.4.6
X-Spam-Checker-Version: SpamAssassin 3.4.6 (2021-04-09) on
        lindbergh.monkeyblade.net
Precedence: bulk
List-ID: <linux-gpio.vger.kernel.org>
X-Mailing-List: linux-gpio@vger.kernel.org

The interest of maintaining the DaVinci DM644x board files seems
very low. Patches to convert the EVM board to use GPIO descriptors
has not been reviewed, tested or merged for several merge
windows in a row, see link below.

When I look in the logs for the board files I see nothing but
generic kernel maintenance and no testing on real hardware for
years.

I conclude the DM646x board files are unused and can be deleted.

Cc: Kevin Hilman <khilman@baylibre.com>
Cc: Arnd Bergmann <arnd@kernel.org>
Cc: Matt Porter <mporter@konsulko.com>
Cc: Sekhar Nori <nsekhar@ti.com>
Cc: Bartosz Golaszewski <bgolaszewski@baylibre.com>
Link: https://lore.kernel.org/linux-arm-kernel/20220507124536.171930-2-linus.walleij@linaro.org/
Signed-off-by: Linus Walleij <linus.walleij@linaro.org>
---
 arch/arm/mach-davinci/Kconfig            |  17 -
 arch/arm/mach-davinci/Makefile           |   2 -
 arch/arm/mach-davinci/board-dm646x-evm.c | 873 -----------------------
 arch/arm/mach-davinci/dm646x.c           | 726 -------------------
 4 files changed, 1618 deletions(-)
 delete mode 100644 arch/arm/mach-davinci/board-dm646x-evm.c
 delete mode 100644 arch/arm/mach-davinci/dm646x.c

diff --git a/arch/arm/mach-davinci/Kconfig b/arch/arm/mach-davinci/Kconfig
index 91dc05fe642f..95ca60649c34 100644
--- a/arch/arm/mach-davinci/Kconfig
+++ b/arch/arm/mach-davinci/Kconfig
@@ -24,11 +24,6 @@ config ARCH_DAVINCI_DM355
 	select DAVINCI_AINTC
 	select ARCH_DAVINCI_DMx
 
-config ARCH_DAVINCI_DM646x
-	bool "DaVinci 646x based system"
-	select DAVINCI_AINTC
-	select ARCH_DAVINCI_DMx
-
 config ARCH_DAVINCI_DA830
 	bool "DA830/OMAP-L137/AM17x based system"
 	depends on !ARCH_DAVINCI_DMx || (AUTO_ZRELADDR && ARM_PATCH_PHYS_VIRT)
@@ -77,18 +72,6 @@ config MACH_DM355_LEOPARD
 	  Configure this option to specify the whether the board used
 	  for development is a DM355 Leopard board.
 
-config MACH_DAVINCI_DM6467_EVM
-	bool "TI DM6467 EVM"
-	default ARCH_DAVINCI_DM646x
-	depends on ARCH_DAVINCI_DM646x
-	select MACH_DAVINCI_DM6467TEVM
-	help
-	  Configure this option to specify the whether the board used
-	  for development is a DM6467 EVM
-
-config MACH_DAVINCI_DM6467TEVM
-	bool
-
 config MACH_DAVINCI_DM365_EVM
 	bool "TI DM365 EVM"
 	default ARCH_DAVINCI_DM365
diff --git a/arch/arm/mach-davinci/Makefile b/arch/arm/mach-davinci/Makefile
index 5da1875d880f..3f4894aa7528 100644
--- a/arch/arm/mach-davinci/Makefile
+++ b/arch/arm/mach-davinci/Makefile
@@ -11,7 +11,6 @@ obj-$(CONFIG_DAVINCI_MUX)		+= mux.o
 
 # Chip specific
 obj-$(CONFIG_ARCH_DAVINCI_DM355)        += dm355.o devices.o
-obj-$(CONFIG_ARCH_DAVINCI_DM646x)       += dm646x.o devices.o
 obj-$(CONFIG_ARCH_DAVINCI_DM365)	+= dm365.o devices.o
 obj-$(CONFIG_ARCH_DAVINCI_DA830)	+= da830.o devices-da8xx.o usb-da8xx.o
 obj-$(CONFIG_ARCH_DAVINCI_DA850)	+= da850.o devices-da8xx.o usb-da8xx.o
@@ -20,7 +19,6 @@ obj-$(CONFIG_ARCH_DAVINCI_DA850)	+= da850.o devices-da8xx.o usb-da8xx.o
 obj-$(CONFIG_MACH_DA8XX_DT)		+= da8xx-dt.o pdata-quirks.o
 obj-$(CONFIG_MACH_DAVINCI_DM355_EVM)	+= board-dm355-evm.o
 obj-$(CONFIG_MACH_DM355_LEOPARD)	+= board-dm355-leopard.o
-obj-$(CONFIG_MACH_DAVINCI_DM6467_EVM)	+= board-dm646x-evm.o
 obj-$(CONFIG_MACH_DAVINCI_DM365_EVM)	+= board-dm365-evm.o
 obj-$(CONFIG_MACH_DAVINCI_DA830_EVM)	+= board-da830-evm.o
 obj-$(CONFIG_MACH_DAVINCI_DA850_EVM)	+= board-da850-evm.o
diff --git a/arch/arm/mach-davinci/board-dm646x-evm.c b/arch/arm/mach-davinci/board-dm646x-evm.c
deleted file mode 100644
index 84ad065e98c2..000000000000
--- a/arch/arm/mach-davinci/board-dm646x-evm.c
+++ /dev/null
@@ -1,873 +0,0 @@
-/*
- * TI DaVinci DM646X EVM board
- *
- * Derived from: arch/arm/mach-davinci/board-evm.c
- * Copyright (C) 2006 Texas Instruments.
- *
- * (C) 2007-2008, MontaVista Software, Inc.
- *
- * This file is licensed under the terms of the GNU General Public License
- * version 2. This program is licensed "as is" without any warranty of any
- * kind, whether express or implied.
- *
- */
-
-/**************************************************************************
- * Included Files
- **************************************************************************/
-
-#include <linux/kernel.h>
-#include <linux/init.h>
-#include <linux/leds.h>
-#include <linux/gpio.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/property.h>
-#include <linux/platform_data/pcf857x.h>
-#include <linux/platform_data/ti-aemif.h>
-
-#include <media/i2c/tvp514x.h>
-#include <media/i2c/adv7343.h>
-
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/rawnand.h>
-#include <linux/mtd/partitions.h>
-#include <linux/nvmem-provider.h>
-#include <linux/clk.h>
-#include <linux/export.h>
-#include <linux/platform_data/gpio-davinci.h>
-#include <linux/platform_data/i2c-davinci.h>
-#include <linux/platform_data/mtd-davinci.h>
-#include <linux/platform_data/mtd-davinci-aemif.h>
-
-#include <asm/mach-types.h>
-#include <asm/mach/arch.h>
-
-#include "common.h"
-#include "serial.h"
-#include "davinci.h"
-#include "irqs.h"
-
-#define NAND_BLOCK_SIZE		SZ_128K
-
-/* Note: We are setting first partition as 'bootloader' constituting UBL, U-Boot
- * and U-Boot environment this avoids dependency on any particular combination
- * of UBL, U-Boot or flashing tools etc.
- */
-static struct mtd_partition davinci_nand_partitions[] = {
-	{
-		/* UBL, U-Boot with environment */
-		.name		= "bootloader",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= 16 * NAND_BLOCK_SIZE,
-		.mask_flags	= MTD_WRITEABLE,	/* force read-only */
-	}, {
-		.name		= "kernel",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= SZ_4M,
-		.mask_flags	= 0,
-	}, {
-		.name		= "filesystem",
-		.offset		= MTDPART_OFS_APPEND,
-		.size		= MTDPART_SIZ_FULL,
-		.mask_flags	= 0,
-	}
-};
-
-static struct davinci_aemif_timing dm6467tevm_nandflash_timing = {
-	.wsetup		= 29,
-	.wstrobe	= 24,
-	.whold		= 14,
-	.rsetup		= 19,
-	.rstrobe	= 33,
-	.rhold		= 0,
-	.ta		= 29,
-};
-
-static struct davinci_nand_pdata davinci_nand_data = {
-	.core_chipsel		= 0,
-	.mask_cle 		= 0x80000,
-	.mask_ale 		= 0x40000,
-	.parts			= davinci_nand_partitions,
-	.nr_parts		= ARRAY_SIZE(davinci_nand_partitions),
-	.engine_type		= NAND_ECC_ENGINE_TYPE_ON_HOST,
-	.ecc_bits		= 1,
-	.options		= 0,
-};
-
-static struct resource davinci_nand_resources[] = {
-	{
-		.start		= DM646X_ASYNC_EMIF_CS2_SPACE_BASE,
-		.end		= DM646X_ASYNC_EMIF_CS2_SPACE_BASE + SZ_32M - 1,
-		.flags		= IORESOURCE_MEM,
-	}, {
-		.start		= DM646X_ASYNC_EMIF_CONTROL_BASE,
-		.end		= DM646X_ASYNC_EMIF_CONTROL_BASE + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device davinci_aemif_devices[] = {
-	{
-		.name		= "davinci_nand",
-		.id		= 0,
-		.num_resources	= ARRAY_SIZE(davinci_nand_resources),
-		.resource	= davinci_nand_resources,
-		.dev		= {
-			.platform_data	= &davinci_nand_data,
-		},
-	},
-};
-
-static struct resource davinci_aemif_resources[] = {
-	{
-		.start	= DM646X_ASYNC_EMIF_CONTROL_BASE,
-		.end	= DM646X_ASYNC_EMIF_CONTROL_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct aemif_abus_data davinci_aemif_abus_data[] = {
-	{
-		.cs	= 1,
-	},
-};
-
-static struct aemif_platform_data davinci_aemif_pdata = {
-	.abus_data		= davinci_aemif_abus_data,
-	.num_abus_data		= ARRAY_SIZE(davinci_aemif_abus_data),
-	.sub_devices		= davinci_aemif_devices,
-	.num_sub_devices	= ARRAY_SIZE(davinci_aemif_devices),
-};
-
-static struct platform_device davinci_aemif_device = {
-	.name		= "ti-aemif",
-	.id		= -1,
-	.dev = {
-		.platform_data	= &davinci_aemif_pdata,
-	},
-	.resource	= davinci_aemif_resources,
-	.num_resources	= ARRAY_SIZE(davinci_aemif_resources),
-};
-
-#define HAS_ATA		(IS_ENABLED(CONFIG_BLK_DEV_PALMCHIP_BK3710) || \
-			 IS_ENABLED(CONFIG_PATA_BK3710))
-
-#ifdef CONFIG_I2C
-/* CPLD Register 0 bits to control ATA */
-#define DM646X_EVM_ATA_RST		BIT(0)
-#define DM646X_EVM_ATA_PWD		BIT(1)
-
-/* CPLD Register 0 Client: used for I/O Control */
-static int cpld_reg0_probe(struct i2c_client *client)
-{
-	if (HAS_ATA) {
-		u8 data;
-		struct i2c_msg msg[2] = {
-			{
-				.addr = client->addr,
-				.flags = I2C_M_RD,
-				.len = 1,
-				.buf = &data,
-			},
-			{
-				.addr = client->addr,
-				.flags = 0,
-				.len = 1,
-				.buf = &data,
-			},
-		};
-
-		/* Clear ATA_RSTn and ATA_PWD bits to enable ATA operation. */
-		i2c_transfer(client->adapter, msg, 1);
-		data &= ~(DM646X_EVM_ATA_RST | DM646X_EVM_ATA_PWD);
-		i2c_transfer(client->adapter, msg + 1, 1);
-	}
-
-	return 0;
-}
-
-static const struct i2c_device_id cpld_reg_ids[] = {
-	{ "cpld_reg0", 0, },
-	{ },
-};
-
-static struct i2c_driver dm6467evm_cpld_driver = {
-	.driver.name	= "cpld_reg0",
-	.id_table	= cpld_reg_ids,
-	.probe_new	= cpld_reg0_probe,
-};
-
-/* LEDS */
-
-static struct gpio_led evm_leds[] = {
-	{ .name = "DS1", .active_low = 1, },
-	{ .name = "DS2", .active_low = 1, },
-	{ .name = "DS3", .active_low = 1, },
-	{ .name = "DS4", .active_low = 1, },
-};
-
-static const struct gpio_led_platform_data evm_led_data = {
-	.num_leds = ARRAY_SIZE(evm_leds),
-	.leds     = evm_leds,
-};
-
-static struct platform_device *evm_led_dev;
-
-static int evm_led_setup(struct i2c_client *client, int gpio,
-			unsigned int ngpio, void *c)
-{
-	struct gpio_led *leds = evm_leds;
-	int status;
-
-	while (ngpio--) {
-		leds->gpio = gpio++;
-		leds++;
-	}
-
-	evm_led_dev = platform_device_alloc("leds-gpio", 0);
-	platform_device_add_data(evm_led_dev, &evm_led_data,
-				sizeof(evm_led_data));
-
-	evm_led_dev->dev.parent = &client->dev;
-	status = platform_device_add(evm_led_dev);
-	if (status < 0) {
-		platform_device_put(evm_led_dev);
-		evm_led_dev = NULL;
-	}
-	return status;
-}
-
-static int evm_led_teardown(struct i2c_client *client, int gpio,
-				unsigned ngpio, void *c)
-{
-	if (evm_led_dev) {
-		platform_device_unregister(evm_led_dev);
-		evm_led_dev = NULL;
-	}
-	return 0;
-}
-
-static int evm_sw_gpio[4] = { -EINVAL, -EINVAL, -EINVAL, -EINVAL };
-
-static int evm_sw_setup(struct i2c_client *client, int gpio,
-			unsigned ngpio, void *c)
-{
-	int status;
-	int i;
-	char label[10];
-
-	for (i = 0; i < 4; ++i) {
-		snprintf(label, 10, "user_sw%d", i);
-		status = gpio_request(gpio, label);
-		if (status)
-			goto out_free;
-		evm_sw_gpio[i] = gpio++;
-
-		status = gpio_direction_input(evm_sw_gpio[i]);
-		if (status)
-			goto out_free;
-
-		status = gpio_export(evm_sw_gpio[i], 0);
-		if (status)
-			goto out_free;
-	}
-	return 0;
-
-out_free:
-	for (i = 0; i < 4; ++i) {
-		if (evm_sw_gpio[i] != -EINVAL) {
-			gpio_free(evm_sw_gpio[i]);
-			evm_sw_gpio[i] = -EINVAL;
-		}
-	}
-	return status;
-}
-
-static int evm_sw_teardown(struct i2c_client *client, int gpio,
-			unsigned ngpio, void *c)
-{
-	int i;
-
-	for (i = 0; i < 4; ++i) {
-		if (evm_sw_gpio[i] != -EINVAL) {
-			gpio_unexport(evm_sw_gpio[i]);
-			gpio_free(evm_sw_gpio[i]);
-			evm_sw_gpio[i] = -EINVAL;
-		}
-	}
-	return 0;
-}
-
-static int evm_pcf_setup(struct i2c_client *client, int gpio,
-			unsigned int ngpio, void *c)
-{
-	int status;
-
-	if (ngpio < 8)
-		return -EINVAL;
-
-	status = evm_sw_setup(client, gpio, 4, c);
-	if (status)
-		return status;
-
-	return evm_led_setup(client, gpio+4, 4, c);
-}
-
-static void evm_pcf_teardown(struct i2c_client *client, int gpio,
-			unsigned int ngpio, void *c)
-{
-	BUG_ON(ngpio < 8);
-
-	evm_sw_teardown(client, gpio, 4, c);
-	evm_led_teardown(client, gpio+4, 4, c);
-}
-
-static struct pcf857x_platform_data pcf_data = {
-	.gpio_base	= DAVINCI_N_GPIO+1,
-	.setup		= evm_pcf_setup,
-	.teardown	= evm_pcf_teardown,
-};
-
-/* Most of this EEPROM is unused, but U-Boot uses some data:
- *  - 0x7f00, 6 bytes Ethernet Address
- *  - ... newer boards may have more
- */
-
-static struct nvmem_cell_info dm646x_evm_nvmem_cells[] = {
-	{
-		.name		= "macaddr",
-		.offset		= 0x7f00,
-		.bytes		= ETH_ALEN,
-	}
-};
-
-static struct nvmem_cell_table dm646x_evm_nvmem_cell_table = {
-	.nvmem_name	= "1-00500",
-	.cells		= dm646x_evm_nvmem_cells,
-	.ncells		= ARRAY_SIZE(dm646x_evm_nvmem_cells),
-};
-
-static struct nvmem_cell_lookup dm646x_evm_nvmem_cell_lookup = {
-	.nvmem_name	= "1-00500",
-	.cell_name	= "macaddr",
-	.dev_id		= "davinci_emac.1",
-	.con_id		= "mac-address",
-};
-
-static const struct property_entry eeprom_properties[] = {
-	PROPERTY_ENTRY_U32("pagesize", 64),
-	{ }
-};
-
-static const struct software_node eeprom_node = {
-	.properties = eeprom_properties,
-};
-#endif
-
-static u8 dm646x_iis_serializer_direction[] = {
-       TX_MODE, RX_MODE, INACTIVE_MODE, INACTIVE_MODE,
-};
-
-static u8 dm646x_dit_serializer_direction[] = {
-       TX_MODE,
-};
-
-static struct snd_platform_data dm646x_evm_snd_data[] = {
-	{
-		.tx_dma_offset  = 0x400,
-		.rx_dma_offset  = 0x400,
-		.op_mode        = DAVINCI_MCASP_IIS_MODE,
-		.num_serializer = ARRAY_SIZE(dm646x_iis_serializer_direction),
-		.tdm_slots      = 2,
-		.serial_dir     = dm646x_iis_serializer_direction,
-		.asp_chan_q     = EVENTQ_0,
-	},
-	{
-		.tx_dma_offset  = 0x400,
-		.rx_dma_offset  = 0,
-		.op_mode        = DAVINCI_MCASP_DIT_MODE,
-		.num_serializer = ARRAY_SIZE(dm646x_dit_serializer_direction),
-		.tdm_slots      = 32,
-		.serial_dir     = dm646x_dit_serializer_direction,
-		.asp_chan_q     = EVENTQ_0,
-	},
-};
-
-#ifdef CONFIG_I2C
-static struct i2c_client *cpld_client;
-
-static int cpld_video_probe(struct i2c_client *client)
-{
-	cpld_client = client;
-	return 0;
-}
-
-static int cpld_video_remove(struct i2c_client *client)
-{
-	cpld_client = NULL;
-	return 0;
-}
-
-static const struct i2c_device_id cpld_video_id[] = {
-	{ "cpld_video", 0 },
-	{ }
-};
-
-static struct i2c_driver cpld_video_driver = {
-	.driver = {
-		.name	= "cpld_video",
-	},
-	.probe_new	= cpld_video_probe,
-	.remove		= cpld_video_remove,
-	.id_table	= cpld_video_id,
-};
-
-static void evm_init_cpld(void)
-{
-	i2c_add_driver(&cpld_video_driver);
-}
-
-static struct i2c_board_info __initdata i2c_info[] =  {
-	{
-		I2C_BOARD_INFO("24c256", 0x50),
-		.swnode = &eeprom_node,
-	},
-	{
-		I2C_BOARD_INFO("pcf8574a", 0x38),
-		.platform_data	= &pcf_data,
-	},
-	{
-		I2C_BOARD_INFO("cpld_reg0", 0x3a),
-	},
-	{
-		I2C_BOARD_INFO("tlv320aic33", 0x18),
-	},
-	{
-		I2C_BOARD_INFO("cpld_video", 0x3b),
-	},
-};
-
-static struct davinci_i2c_platform_data i2c_pdata = {
-	.bus_freq       = 100 /* kHz */,
-	.bus_delay      = 0 /* usec */,
-};
-
-#define VCH2CLK_MASK		(BIT_MASK(10) | BIT_MASK(9) | BIT_MASK(8))
-#define VCH2CLK_SYSCLK8		(BIT(9))
-#define VCH2CLK_AUXCLK		(BIT(9) | BIT(8))
-#define VCH3CLK_MASK		(BIT_MASK(14) | BIT_MASK(13) | BIT_MASK(12))
-#define VCH3CLK_SYSCLK8		(BIT(13))
-#define VCH3CLK_AUXCLK		(BIT(14) | BIT(13))
-
-#define VIDCH2CLK		(BIT(10))
-#define VIDCH3CLK		(BIT(11))
-#define VIDCH1CLK		(BIT(4))
-#define TVP7002_INPUT		(BIT(4))
-#define TVP5147_INPUT		(~BIT(4))
-#define VPIF_INPUT_ONE_CHANNEL	(BIT(5))
-#define VPIF_INPUT_TWO_CHANNEL	(~BIT(5))
-#define TVP5147_CH0		"tvp514x-0"
-#define TVP5147_CH1		"tvp514x-1"
-
-/* spin lock for updating above registers */
-static spinlock_t vpif_reg_lock;
-
-static int set_vpif_clock(int mux_mode, int hd)
-{
-	unsigned long flags;
-	unsigned int value;
-	int val = 0;
-	int err = 0;
-
-	if (!cpld_client)
-		return -ENXIO;
-
-	/* disable the clock */
-	spin_lock_irqsave(&vpif_reg_lock, flags);
-	value = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));
-	value |= (VIDCH3CLK | VIDCH2CLK);
-	__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));
-	spin_unlock_irqrestore(&vpif_reg_lock, flags);
-
-	val = i2c_smbus_read_byte(cpld_client);
-	if (val < 0)
-		return val;
-
-	if (mux_mode == 1)
-		val &= ~0x40;
-	else
-		val |= 0x40;
-
-	err = i2c_smbus_write_byte(cpld_client, val);
-	if (err)
-		return err;
-
-	value = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VIDCLKCTL));
-	value &= ~(VCH2CLK_MASK);
-	value &= ~(VCH3CLK_MASK);
-
-	if (hd >= 1)
-		value |= (VCH2CLK_SYSCLK8 | VCH3CLK_SYSCLK8);
-	else
-		value |= (VCH2CLK_AUXCLK | VCH3CLK_AUXCLK);
-
-	__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VIDCLKCTL));
-
-	spin_lock_irqsave(&vpif_reg_lock, flags);
-	value = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));
-	/* enable the clock */
-	value &= ~(VIDCH3CLK | VIDCH2CLK);
-	__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));
-	spin_unlock_irqrestore(&vpif_reg_lock, flags);
-
-	return 0;
-}
-
-static struct vpif_subdev_info dm646x_vpif_subdev[] = {
-	{
-		.name	= "adv7343",
-		.board_info = {
-			I2C_BOARD_INFO("adv7343", 0x2a),
-		},
-	},
-	{
-		.name	= "ths7303",
-		.board_info = {
-			I2C_BOARD_INFO("ths7303", 0x2c),
-		},
-	},
-};
-
-static const struct vpif_output dm6467_ch0_outputs[] = {
-	{
-		.output = {
-			.index = 0,
-			.name = "Composite",
-			.type = V4L2_OUTPUT_TYPE_ANALOG,
-			.capabilities = V4L2_OUT_CAP_STD,
-			.std = V4L2_STD_ALL,
-		},
-		.subdev_name = "adv7343",
-		.output_route = ADV7343_COMPOSITE_ID,
-	},
-	{
-		.output = {
-			.index = 1,
-			.name = "Component",
-			.type = V4L2_OUTPUT_TYPE_ANALOG,
-			.capabilities = V4L2_OUT_CAP_DV_TIMINGS,
-		},
-		.subdev_name = "adv7343",
-		.output_route = ADV7343_COMPONENT_ID,
-	},
-	{
-		.output = {
-			.index = 2,
-			.name = "S-Video",
-			.type = V4L2_OUTPUT_TYPE_ANALOG,
-			.capabilities = V4L2_OUT_CAP_STD,
-			.std = V4L2_STD_ALL,
-		},
-		.subdev_name = "adv7343",
-		.output_route = ADV7343_SVIDEO_ID,
-	},
-};
-
-static struct vpif_display_config dm646x_vpif_display_config = {
-	.set_clock	= set_vpif_clock,
-	.subdevinfo	= dm646x_vpif_subdev,
-	.subdev_count	= ARRAY_SIZE(dm646x_vpif_subdev),
-	.i2c_adapter_id = 1,
-	.chan_config[0] = {
-		.outputs = dm6467_ch0_outputs,
-		.output_count = ARRAY_SIZE(dm6467_ch0_outputs),
-	},
-	.card_name	= "DM646x EVM Video Display",
-};
-
-/**
- * setup_vpif_input_path()
- * @channel: channel id (0 - CH0, 1 - CH1)
- * @sub_dev_name: ptr sub device name
- *
- * This will set vpif input to capture data from tvp514x or
- * tvp7002.
- */
-static int setup_vpif_input_path(int channel, const char *sub_dev_name)
-{
-	int err = 0;
-	int val;
-
-	/* for channel 1, we don't do anything */
-	if (channel != 0)
-		return 0;
-
-	if (!cpld_client)
-		return -ENXIO;
-
-	val = i2c_smbus_read_byte(cpld_client);
-	if (val < 0)
-		return val;
-
-	if (!strcmp(sub_dev_name, TVP5147_CH0) ||
-	    !strcmp(sub_dev_name, TVP5147_CH1))
-		val &= TVP5147_INPUT;
-	else
-		val |= TVP7002_INPUT;
-
-	err = i2c_smbus_write_byte(cpld_client, val);
-	if (err)
-		return err;
-	return 0;
-}
-
-/**
- * setup_vpif_input_channel_mode()
- * @mux_mode:  mux mode. 0 - 1 channel or (1) - 2 channel
- *
- * This will setup input mode to one channel (TVP7002) or 2 channel (TVP5147)
- */
-static int setup_vpif_input_channel_mode(int mux_mode)
-{
-	unsigned long flags;
-	int err = 0;
-	int val;
-	u32 value;
-
-	if (!cpld_client)
-		return -ENXIO;
-
-	val = i2c_smbus_read_byte(cpld_client);
-	if (val < 0)
-		return val;
-
-	spin_lock_irqsave(&vpif_reg_lock, flags);
-	value = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VIDCLKCTL));
-	if (mux_mode) {
-		val &= VPIF_INPUT_TWO_CHANNEL;
-		value |= VIDCH1CLK;
-	} else {
-		val |= VPIF_INPUT_ONE_CHANNEL;
-		value &= ~VIDCH1CLK;
-	}
-	__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VIDCLKCTL));
-	spin_unlock_irqrestore(&vpif_reg_lock, flags);
-
-	err = i2c_smbus_write_byte(cpld_client, val);
-	if (err)
-		return err;
-
-	return 0;
-}
-
-static struct tvp514x_platform_data tvp5146_pdata = {
-	.clk_polarity = 0,
-	.hs_polarity = 1,
-	.vs_polarity = 1
-};
-
-#define TVP514X_STD_ALL (V4L2_STD_NTSC | V4L2_STD_PAL)
-
-static struct vpif_subdev_info vpif_capture_sdev_info[] = {
-	{
-		.name	= TVP5147_CH0,
-		.board_info = {
-			I2C_BOARD_INFO("tvp5146", 0x5d),
-			.platform_data = &tvp5146_pdata,
-		},
-	},
-	{
-		.name	= TVP5147_CH1,
-		.board_info = {
-			I2C_BOARD_INFO("tvp5146", 0x5c),
-			.platform_data = &tvp5146_pdata,
-		},
-	},
-};
-
-static struct vpif_input dm6467_ch0_inputs[] = {
-	{
-		.input = {
-			.index = 0,
-			.name = "Composite",
-			.type = V4L2_INPUT_TYPE_CAMERA,
-			.capabilities = V4L2_IN_CAP_STD,
-			.std = TVP514X_STD_ALL,
-		},
-		.subdev_name = TVP5147_CH0,
-		.input_route = INPUT_CVBS_VI2B,
-		.output_route = OUTPUT_10BIT_422_EMBEDDED_SYNC,
-	},
-};
-
-static struct vpif_input dm6467_ch1_inputs[] = {
-       {
-		.input = {
-			.index = 0,
-			.name = "S-Video",
-			.type = V4L2_INPUT_TYPE_CAMERA,
-			.capabilities = V4L2_IN_CAP_STD,
-			.std = TVP514X_STD_ALL,
-		},
-		.subdev_name = TVP5147_CH1,
-		.input_route = INPUT_SVIDEO_VI2C_VI1C,
-		.output_route = OUTPUT_10BIT_422_EMBEDDED_SYNC,
-	},
-};
-
-static struct vpif_capture_config dm646x_vpif_capture_cfg = {
-	.setup_input_path = setup_vpif_input_path,
-	.setup_input_channel_mode = setup_vpif_input_channel_mode,
-	.subdev_info = vpif_capture_sdev_info,
-	.subdev_count = ARRAY_SIZE(vpif_capture_sdev_info),
-	.i2c_adapter_id = 1,
-	.chan_config[0] = {
-		.inputs = dm6467_ch0_inputs,
-		.input_count = ARRAY_SIZE(dm6467_ch0_inputs),
-		.vpif_if = {
-			.if_type = VPIF_IF_BT656,
-			.hd_pol = 1,
-			.vd_pol = 1,
-			.fid_pol = 0,
-		},
-	},
-	.chan_config[1] = {
-		.inputs = dm6467_ch1_inputs,
-		.input_count = ARRAY_SIZE(dm6467_ch1_inputs),
-		.vpif_if = {
-			.if_type = VPIF_IF_BT656,
-			.hd_pol = 1,
-			.vd_pol = 1,
-			.fid_pol = 0,
-		},
-	},
-	.card_name = "DM646x EVM Video Capture",
-};
-
-static void __init evm_init_video(void)
-{
-	spin_lock_init(&vpif_reg_lock);
-
-	dm646x_setup_vpif(&dm646x_vpif_display_config,
-			  &dm646x_vpif_capture_cfg);
-}
-
-static void __init evm_init_i2c(void)
-{
-	davinci_init_i2c(&i2c_pdata);
-	i2c_add_driver(&dm6467evm_cpld_driver);
-	i2c_register_board_info(1, i2c_info, ARRAY_SIZE(i2c_info));
-	evm_init_cpld();
-	evm_init_video();
-}
-#endif
-
-#define DM646X_REF_FREQ			27000000
-#define DM646X_AUX_FREQ			24000000
-#define DM6467T_EVM_REF_FREQ		33000000
-
-static void __init davinci_map_io(void)
-{
-	dm646x_init();
-}
-
-static void __init dm646x_evm_init_time(void)
-{
-	dm646x_init_time(DM646X_REF_FREQ, DM646X_AUX_FREQ);
-}
-
-static void __init dm6467t_evm_init_time(void)
-{
-	dm646x_init_time(DM6467T_EVM_REF_FREQ, DM646X_AUX_FREQ);
-}
-
-#define DM646X_EVM_PHY_ID		"davinci_mdio-0:01"
-/*
- * The following EDMA channels/slots are not being used by drivers (for
- * example: Timer, GPIO, UART events etc) on dm646x, hence they are being
- * reserved for codecs on the DSP side.
- */
-static const s16 dm646x_dma_rsv_chans[][2] = {
-	/* (offset, number) */
-	{ 0,  4},
-	{13,  3},
-	{24,  4},
-	{30,  2},
-	{54,  3},
-	{-1, -1}
-};
-
-static const s16 dm646x_dma_rsv_slots[][2] = {
-	/* (offset, number) */
-	{ 0,  4},
-	{13,  3},
-	{24,  4},
-	{30,  2},
-	{54,  3},
-	{128, 384},
-	{-1, -1}
-};
-
-static struct edma_rsv_info dm646x_edma_rsv[] = {
-	{
-		.rsv_chans	= dm646x_dma_rsv_chans,
-		.rsv_slots	= dm646x_dma_rsv_slots,
-	},
-};
-
-static __init void evm_init(void)
-{
-	int ret;
-	struct davinci_soc_info *soc_info = &davinci_soc_info;
-
-	dm646x_register_clocks();
-
-	ret = dm646x_gpio_register();
-	if (ret)
-		pr_warn("%s: GPIO init failed: %d\n", __func__, ret);
-
-#ifdef CONFIG_I2C
-	nvmem_add_cell_table(&dm646x_evm_nvmem_cell_table);
-	nvmem_add_cell_lookups(&dm646x_evm_nvmem_cell_lookup, 1);
-	evm_init_i2c();
-#endif
-
-	davinci_serial_init(dm646x_serial_device);
-	dm646x_init_mcasp0(&dm646x_evm_snd_data[0]);
-	dm646x_init_mcasp1(&dm646x_evm_snd_data[1]);
-
-	if (machine_is_davinci_dm6467tevm())
-		davinci_nand_data.timing = &dm6467tevm_nandflash_timing;
-
-	if (platform_device_register(&davinci_aemif_device))
-		pr_warn("%s: Cannot register AEMIF device.\n", __func__);
-
-	dm646x_init_edma(dm646x_edma_rsv);
-
-	if (HAS_ATA)
-		davinci_init_ide();
-
-	soc_info->emac_pdata->phy_id = DM646X_EVM_PHY_ID;
-}
-
-MACHINE_START(DAVINCI_DM6467_EVM, "DaVinci DM646x EVM")
-	.atag_offset  = 0x100,
-	.map_io       = davinci_map_io,
-	.init_irq     = dm646x_init_irq,
-	.init_time	= dm646x_evm_init_time,
-	.init_machine = evm_init,
-	.init_late	= davinci_init_late,
-	.dma_zone_size	= SZ_128M,
-MACHINE_END
-
-MACHINE_START(DAVINCI_DM6467TEVM, "DaVinci DM6467T EVM")
-	.atag_offset  = 0x100,
-	.map_io       = davinci_map_io,
-	.init_irq     = dm646x_init_irq,
-	.init_time	= dm6467t_evm_init_time,
-	.init_machine = evm_init,
-	.init_late	= davinci_init_late,
-	.dma_zone_size	= SZ_128M,
-MACHINE_END
-
diff --git a/arch/arm/mach-davinci/dm646x.c b/arch/arm/mach-davinci/dm646x.c
deleted file mode 100644
index 971b2d4e2595..000000000000
--- a/arch/arm/mach-davinci/dm646x.c
+++ /dev/null
@@ -1,726 +0,0 @@
-/*
- * TI DaVinci DM646x chip specific setup
- *
- * Author: Kevin Hilman, Deep Root Systems, LLC
- *
- * 2007 (c) Deep Root Systems, LLC. This file is licensed under
- * the terms of the GNU General Public License version 2. This program
- * is licensed "as is" without any warranty of any kind, whether express
- * or implied.
- */
-
-#include <linux/clk-provider.h>
-#include <linux/clk/davinci.h>
-#include <linux/clkdev.h>
-#include <linux/dma-mapping.h>
-#include <linux/dmaengine.h>
-#include <linux/init.h>
-#include <linux/io.h>
-#include <linux/irqchip/irq-davinci-aintc.h>
-#include <linux/platform_data/edma.h>
-#include <linux/platform_data/gpio-davinci.h>
-#include <linux/platform_device.h>
-#include <linux/serial_8250.h>
-
-#include <clocksource/timer-davinci.h>
-
-#include <asm/mach/map.h>
-
-#include "common.h"
-#include "cputype.h"
-#include "serial.h"
-#include "asp.h"
-#include "davinci.h"
-#include "irqs.h"
-#include "mux.h"
-
-#define DAVINCI_VPIF_BASE       (0x01C12000)
-
-#define VDD3P3V_VID_MASK	(BIT_MASK(3) | BIT_MASK(2) | BIT_MASK(1) |\
-					BIT_MASK(0))
-#define VSCLKDIS_MASK		(BIT_MASK(11) | BIT_MASK(10) | BIT_MASK(9) |\
-					BIT_MASK(8))
-
-#define DM646X_EMAC_BASE		0x01c80000
-#define DM646X_EMAC_MDIO_BASE		(DM646X_EMAC_BASE + 0x4000)
-#define DM646X_EMAC_CNTRL_OFFSET	0x0000
-#define DM646X_EMAC_CNTRL_MOD_OFFSET	0x1000
-#define DM646X_EMAC_CNTRL_RAM_OFFSET	0x2000
-#define DM646X_EMAC_CNTRL_RAM_SIZE	0x2000
-
-static struct emac_platform_data dm646x_emac_pdata = {
-	.ctrl_reg_offset	= DM646X_EMAC_CNTRL_OFFSET,
-	.ctrl_mod_reg_offset	= DM646X_EMAC_CNTRL_MOD_OFFSET,
-	.ctrl_ram_offset	= DM646X_EMAC_CNTRL_RAM_OFFSET,
-	.ctrl_ram_size		= DM646X_EMAC_CNTRL_RAM_SIZE,
-	.version		= EMAC_VERSION_2,
-};
-
-static struct resource dm646x_emac_resources[] = {
-	{
-		.start	= DM646X_EMAC_BASE,
-		.end	= DM646X_EMAC_BASE + SZ_16K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_EMACRXTHINT),
-		.end	= DAVINCI_INTC_IRQ(IRQ_DM646X_EMACRXTHINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_EMACRXINT),
-		.end	= DAVINCI_INTC_IRQ(IRQ_DM646X_EMACRXINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_EMACTXINT),
-		.end	= DAVINCI_INTC_IRQ(IRQ_DM646X_EMACTXINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_EMACMISCINT),
-		.end	= DAVINCI_INTC_IRQ(IRQ_DM646X_EMACMISCINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device dm646x_emac_device = {
-	.name		= "davinci_emac",
-	.id		= 1,
-	.dev = {
-		.platform_data	= &dm646x_emac_pdata,
-	},
-	.num_resources	= ARRAY_SIZE(dm646x_emac_resources),
-	.resource	= dm646x_emac_resources,
-};
-
-static struct resource dm646x_mdio_resources[] = {
-	{
-		.start	= DM646X_EMAC_MDIO_BASE,
-		.end	= DM646X_EMAC_MDIO_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device dm646x_mdio_device = {
-	.name		= "davinci_mdio",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(dm646x_mdio_resources),
-	.resource	= dm646x_mdio_resources,
-};
-
-/*
- * Device specific mux setup
- *
- *	soc	description	mux  mode   mode  mux	 dbg
- *				reg  offset mask  mode
- */
-static const struct mux_config dm646x_pins[] = {
-#ifdef CONFIG_DAVINCI_MUX
-MUX_CFG(DM646X, ATAEN,		0,   0,     5,	  1,	 true)
-
-MUX_CFG(DM646X, AUDCK1,		0,   29,    1,	  0,	 false)
-
-MUX_CFG(DM646X, AUDCK0,		0,   28,    1,	  0,	 false)
-
-MUX_CFG(DM646X, CRGMUX,			0,   24,    7,    5,	 true)
-
-MUX_CFG(DM646X, STSOMUX_DISABLE,	0,   22,    3,    0,	 true)
-
-MUX_CFG(DM646X, STSIMUX_DISABLE,	0,   20,    3,    0,	 true)
-
-MUX_CFG(DM646X, PTSOMUX_DISABLE,	0,   18,    3,    0,	 true)
-
-MUX_CFG(DM646X, PTSIMUX_DISABLE,	0,   16,    3,    0,	 true)
-
-MUX_CFG(DM646X, STSOMUX,		0,   22,    3,    2,	 true)
-
-MUX_CFG(DM646X, STSIMUX,		0,   20,    3,    2,	 true)
-
-MUX_CFG(DM646X, PTSOMUX_PARALLEL,	0,   18,    3,    2,	 true)
-
-MUX_CFG(DM646X, PTSIMUX_PARALLEL,	0,   16,    3,    2,	 true)
-
-MUX_CFG(DM646X, PTSOMUX_SERIAL,		0,   18,    3,    3,	 true)
-
-MUX_CFG(DM646X, PTSIMUX_SERIAL,		0,   16,    3,    3,	 true)
-#endif
-};
-
-static u8 dm646x_default_priorities[DAVINCI_N_AINTC_IRQ] = {
-	[IRQ_DM646X_VP_VERTINT0]        = 7,
-	[IRQ_DM646X_VP_VERTINT1]        = 7,
-	[IRQ_DM646X_VP_VERTINT2]        = 7,
-	[IRQ_DM646X_VP_VERTINT3]        = 7,
-	[IRQ_DM646X_VP_ERRINT]          = 7,
-	[IRQ_DM646X_RESERVED_1]         = 7,
-	[IRQ_DM646X_RESERVED_2]         = 7,
-	[IRQ_DM646X_WDINT]              = 7,
-	[IRQ_DM646X_CRGENINT0]          = 7,
-	[IRQ_DM646X_CRGENINT1]          = 7,
-	[IRQ_DM646X_TSIFINT0]           = 7,
-	[IRQ_DM646X_TSIFINT1]           = 7,
-	[IRQ_DM646X_VDCEINT]            = 7,
-	[IRQ_DM646X_USBINT]             = 7,
-	[IRQ_DM646X_USBDMAINT]          = 7,
-	[IRQ_DM646X_PCIINT]             = 7,
-	[IRQ_CCINT0]                    = 7,    /* dma */
-	[IRQ_CCERRINT]                  = 7,    /* dma */
-	[IRQ_TCERRINT0]                 = 7,    /* dma */
-	[IRQ_TCERRINT]                  = 7,    /* dma */
-	[IRQ_DM646X_TCERRINT2]          = 7,
-	[IRQ_DM646X_TCERRINT3]          = 7,
-	[IRQ_DM646X_IDE]                = 7,
-	[IRQ_DM646X_HPIINT]             = 7,
-	[IRQ_DM646X_EMACRXTHINT]        = 7,
-	[IRQ_DM646X_EMACRXINT]          = 7,
-	[IRQ_DM646X_EMACTXINT]          = 7,
-	[IRQ_DM646X_EMACMISCINT]        = 7,
-	[IRQ_DM646X_MCASP0TXINT]        = 7,
-	[IRQ_DM646X_MCASP0RXINT]        = 7,
-	[IRQ_DM646X_RESERVED_3]         = 7,
-	[IRQ_DM646X_MCASP1TXINT]        = 7,
-	[IRQ_TINT0_TINT12]              = 7,    /* clockevent */
-	[IRQ_TINT0_TINT34]              = 7,    /* clocksource */
-	[IRQ_TINT1_TINT12]              = 7,    /* DSP timer */
-	[IRQ_TINT1_TINT34]              = 7,    /* system tick */
-	[IRQ_PWMINT0]                   = 7,
-	[IRQ_PWMINT1]                   = 7,
-	[IRQ_DM646X_VLQINT]             = 7,
-	[IRQ_I2C]                       = 7,
-	[IRQ_UARTINT0]                  = 7,
-	[IRQ_UARTINT1]                  = 7,
-	[IRQ_DM646X_UARTINT2]           = 7,
-	[IRQ_DM646X_SPINT0]             = 7,
-	[IRQ_DM646X_SPINT1]             = 7,
-	[IRQ_DM646X_DSP2ARMINT]         = 7,
-	[IRQ_DM646X_RESERVED_4]         = 7,
-	[IRQ_DM646X_PSCINT]             = 7,
-	[IRQ_DM646X_GPIO0]              = 7,
-	[IRQ_DM646X_GPIO1]              = 7,
-	[IRQ_DM646X_GPIO2]              = 7,
-	[IRQ_DM646X_GPIO3]              = 7,
-	[IRQ_DM646X_GPIO4]              = 7,
-	[IRQ_DM646X_GPIO5]              = 7,
-	[IRQ_DM646X_GPIO6]              = 7,
-	[IRQ_DM646X_GPIO7]              = 7,
-	[IRQ_DM646X_GPIOBNK0]           = 7,
-	[IRQ_DM646X_GPIOBNK1]           = 7,
-	[IRQ_DM646X_GPIOBNK2]           = 7,
-	[IRQ_DM646X_DDRINT]             = 7,
-	[IRQ_DM646X_AEMIFINT]           = 7,
-	[IRQ_COMMTX]                    = 7,
-	[IRQ_COMMRX]                    = 7,
-	[IRQ_EMUINT]                    = 7,
-};
-
-/*----------------------------------------------------------------------*/
-
-/* Four Transfer Controllers on DM646x */
-static s8 dm646x_queue_priority_mapping[][2] = {
-	/* {event queue no, Priority} */
-	{0, 4},
-	{1, 0},
-	{2, 5},
-	{3, 1},
-	{-1, -1},
-};
-
-static const struct dma_slave_map dm646x_edma_map[] = {
-	{ "davinci-mcasp.0", "tx", EDMA_FILTER_PARAM(0, 6) },
-	{ "davinci-mcasp.0", "rx", EDMA_FILTER_PARAM(0, 9) },
-	{ "davinci-mcasp.1", "tx", EDMA_FILTER_PARAM(0, 12) },
-	{ "spi_davinci", "tx", EDMA_FILTER_PARAM(0, 16) },
-	{ "spi_davinci", "rx", EDMA_FILTER_PARAM(0, 17) },
-};
-
-static struct edma_soc_info dm646x_edma_pdata = {
-	.queue_priority_mapping	= dm646x_queue_priority_mapping,
-	.default_queue		= EVENTQ_1,
-	.slave_map		= dm646x_edma_map,
-	.slavecnt		= ARRAY_SIZE(dm646x_edma_map),
-};
-
-static struct resource edma_resources[] = {
-	{
-		.name	= "edma3_cc",
-		.start	= 0x01c00000,
-		.end	= 0x01c00000 + SZ_64K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "edma3_tc0",
-		.start	= 0x01c10000,
-		.end	= 0x01c10000 + SZ_1K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "edma3_tc1",
-		.start	= 0x01c10400,
-		.end	= 0x01c10400 + SZ_1K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "edma3_tc2",
-		.start	= 0x01c10800,
-		.end	= 0x01c10800 + SZ_1K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "edma3_tc3",
-		.start	= 0x01c10c00,
-		.end	= 0x01c10c00 + SZ_1K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "edma3_ccint",
-		.start	= DAVINCI_INTC_IRQ(IRQ_CCINT0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.name	= "edma3_ccerrint",
-		.start	= DAVINCI_INTC_IRQ(IRQ_CCERRINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-	/* not using TC*_ERR */
-};
-
-static const struct platform_device_info dm646x_edma_device __initconst = {
-	.name		= "edma",
-	.id		= 0,
-	.dma_mask	= DMA_BIT_MASK(32),
-	.res		= edma_resources,
-	.num_res	= ARRAY_SIZE(edma_resources),
-	.data		= &dm646x_edma_pdata,
-	.size_data	= sizeof(dm646x_edma_pdata),
-};
-
-static struct resource dm646x_mcasp0_resources[] = {
-	{
-		.name	= "mpu",
-		.start 	= DAVINCI_DM646X_MCASP0_REG_BASE,
-		.end 	= DAVINCI_DM646X_MCASP0_REG_BASE + (SZ_1K << 1) - 1,
-		.flags 	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "tx",
-		.start	= DAVINCI_DM646X_DMA_MCASP0_AXEVT0,
-		.end	= DAVINCI_DM646X_DMA_MCASP0_AXEVT0,
-		.flags	= IORESOURCE_DMA,
-	},
-	{
-		.name	= "rx",
-		.start	= DAVINCI_DM646X_DMA_MCASP0_AREVT0,
-		.end	= DAVINCI_DM646X_DMA_MCASP0_AREVT0,
-		.flags	= IORESOURCE_DMA,
-	},
-	{
-		.name	= "tx",
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_MCASP0TXINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.name	= "rx",
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_MCASP0RXINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-/* DIT mode only, rx is not supported */
-static struct resource dm646x_mcasp1_resources[] = {
-	{
-		.name	= "mpu",
-		.start	= DAVINCI_DM646X_MCASP1_REG_BASE,
-		.end	= DAVINCI_DM646X_MCASP1_REG_BASE + (SZ_1K << 1) - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{
-		.name	= "tx",
-		.start	= DAVINCI_DM646X_DMA_MCASP1_AXEVT1,
-		.end	= DAVINCI_DM646X_DMA_MCASP1_AXEVT1,
-		.flags	= IORESOURCE_DMA,
-	},
-	{
-		.name	= "tx",
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_MCASP1TXINT),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device dm646x_mcasp0_device = {
-	.name		= "davinci-mcasp",
-	.id		= 0,
-	.num_resources	= ARRAY_SIZE(dm646x_mcasp0_resources),
-	.resource	= dm646x_mcasp0_resources,
-};
-
-static struct platform_device dm646x_mcasp1_device = {
-	.name		= "davinci-mcasp",
-	.id		= 1,
-	.num_resources	= ARRAY_SIZE(dm646x_mcasp1_resources),
-	.resource	= dm646x_mcasp1_resources,
-};
-
-static struct platform_device dm646x_dit_device = {
-	.name	= "spdif-dit",
-	.id	= -1,
-};
-
-static u64 vpif_dma_mask = DMA_BIT_MASK(32);
-
-static struct resource vpif_resource[] = {
-	{
-		.start	= DAVINCI_VPIF_BASE,
-		.end	= DAVINCI_VPIF_BASE + 0x03ff,
-		.flags	= IORESOURCE_MEM,
-	}
-};
-
-static struct platform_device vpif_dev = {
-	.name		= "vpif",
-	.id		= -1,
-	.dev		= {
-			.dma_mask 		= &vpif_dma_mask,
-			.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-	.resource	= vpif_resource,
-	.num_resources	= ARRAY_SIZE(vpif_resource),
-};
-
-static struct resource vpif_display_resource[] = {
-	{
-		.start = DAVINCI_INTC_IRQ(IRQ_DM646X_VP_VERTINT2),
-		.end   = DAVINCI_INTC_IRQ(IRQ_DM646X_VP_VERTINT2),
-		.flags = IORESOURCE_IRQ,
-	},
-	{
-		.start = DAVINCI_INTC_IRQ(IRQ_DM646X_VP_VERTINT3),
-		.end   = DAVINCI_INTC_IRQ(IRQ_DM646X_VP_VERTINT3),
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device vpif_display_dev = {
-	.name		= "vpif_display",
-	.id		= -1,
-	.dev		= {
-			.dma_mask 		= &vpif_dma_mask,
-			.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-	.resource	= vpif_display_resource,
-	.num_resources	= ARRAY_SIZE(vpif_display_resource),
-};
-
-static struct resource vpif_capture_resource[] = {
-	{
-		.start = DAVINCI_INTC_IRQ(IRQ_DM646X_VP_VERTINT0),
-		.end   = DAVINCI_INTC_IRQ(IRQ_DM646X_VP_VERTINT0),
-		.flags = IORESOURCE_IRQ,
-	},
-	{
-		.start = DAVINCI_INTC_IRQ(IRQ_DM646X_VP_VERTINT1),
-		.end   = DAVINCI_INTC_IRQ(IRQ_DM646X_VP_VERTINT1),
-		.flags = IORESOURCE_IRQ,
-	},
-};
-
-static struct platform_device vpif_capture_dev = {
-	.name		= "vpif_capture",
-	.id		= -1,
-	.dev		= {
-			.dma_mask 		= &vpif_dma_mask,
-			.coherent_dma_mask	= DMA_BIT_MASK(32),
-	},
-	.resource	= vpif_capture_resource,
-	.num_resources	= ARRAY_SIZE(vpif_capture_resource),
-};
-
-static struct resource dm646x_gpio_resources[] = {
-	{	/* registers */
-		.start	= DAVINCI_GPIO_BASE,
-		.end	= DAVINCI_GPIO_BASE + SZ_4K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-	{	/* interrupt */
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_GPIOBNK0),
-		.end	= DAVINCI_INTC_IRQ(IRQ_DM646X_GPIOBNK0),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_GPIOBNK1),
-		.end	= DAVINCI_INTC_IRQ(IRQ_DM646X_GPIOBNK1),
-		.flags	= IORESOURCE_IRQ,
-	},
-	{
-		.start	= DAVINCI_INTC_IRQ(IRQ_DM646X_GPIOBNK2),
-		.end	= DAVINCI_INTC_IRQ(IRQ_DM646X_GPIOBNK2),
-		.flags	= IORESOURCE_IRQ,
-	},
-};
-
-static struct davinci_gpio_platform_data dm646x_gpio_platform_data = {
-	.no_auto_base	= true,
-	.base		= 0,
-	.ngpio		= 43,
-};
-
-int __init dm646x_gpio_register(void)
-{
-	return davinci_gpio_register(dm646x_gpio_resources,
-				     ARRAY_SIZE(dm646x_gpio_resources),
-				     &dm646x_gpio_platform_data);
-}
-/*----------------------------------------------------------------------*/
-
-static struct map_desc dm646x_io_desc[] = {
-	{
-		.virtual	= IO_VIRT,
-		.pfn		= __phys_to_pfn(IO_PHYS),
-		.length		= IO_SIZE,
-		.type		= MT_DEVICE
-	},
-};
-
-/* Contents of JTAG ID register used to identify exact cpu type */
-static struct davinci_id dm646x_ids[] = {
-	{
-		.variant	= 0x0,
-		.part_no	= 0xb770,
-		.manufacturer	= 0x017,
-		.cpu_id		= DAVINCI_CPU_ID_DM6467,
-		.name		= "dm6467_rev1.x",
-	},
-	{
-		.variant	= 0x1,
-		.part_no	= 0xb770,
-		.manufacturer	= 0x017,
-		.cpu_id		= DAVINCI_CPU_ID_DM6467,
-		.name		= "dm6467_rev3.x",
-	},
-};
-
-/*
- * Bottom half of timer0 is used for clockevent, top half is used for
- * clocksource.
- */
-static const struct davinci_timer_cfg dm646x_timer_cfg = {
-	.reg = DEFINE_RES_IO(DAVINCI_TIMER0_BASE, SZ_4K),
-	.irq = {
-		DEFINE_RES_IRQ(DAVINCI_INTC_IRQ(IRQ_TINT0_TINT12)),
-		DEFINE_RES_IRQ(DAVINCI_INTC_IRQ(IRQ_TINT0_TINT34)),
-	},
-};
-
-static struct plat_serial8250_port dm646x_serial0_platform_data[] = {
-	{
-		.mapbase	= DAVINCI_UART0_BASE,
-		.irq		= DAVINCI_INTC_IRQ(IRQ_UARTINT0),
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM32,
-		.regshift	= 2,
-	},
-	{
-		.flags	= 0,
-	}
-};
-static struct plat_serial8250_port dm646x_serial1_platform_data[] = {
-	{
-		.mapbase	= DAVINCI_UART1_BASE,
-		.irq		= DAVINCI_INTC_IRQ(IRQ_UARTINT1),
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM32,
-		.regshift	= 2,
-	},
-	{
-		.flags	= 0,
-	}
-};
-static struct plat_serial8250_port dm646x_serial2_platform_data[] = {
-	{
-		.mapbase	= DAVINCI_UART2_BASE,
-		.irq		= DAVINCI_INTC_IRQ(IRQ_DM646X_UARTINT2),
-		.flags		= UPF_BOOT_AUTOCONF | UPF_SKIP_TEST |
-				  UPF_IOREMAP,
-		.iotype		= UPIO_MEM32,
-		.regshift	= 2,
-	},
-	{
-		.flags	= 0,
-	}
-};
-
-struct platform_device dm646x_serial_device[] = {
-	{
-		.name			= "serial8250",
-		.id			= PLAT8250_DEV_PLATFORM,
-		.dev			= {
-			.platform_data	= dm646x_serial0_platform_data,
-		}
-	},
-	{
-		.name			= "serial8250",
-		.id			= PLAT8250_DEV_PLATFORM1,
-		.dev			= {
-			.platform_data	= dm646x_serial1_platform_data,
-		}
-	},
-	{
-		.name			= "serial8250",
-		.id			= PLAT8250_DEV_PLATFORM2,
-		.dev			= {
-			.platform_data	= dm646x_serial2_platform_data,
-		}
-	},
-	{
-	}
-};
-
-static const struct davinci_soc_info davinci_soc_info_dm646x = {
-	.io_desc		= dm646x_io_desc,
-	.io_desc_num		= ARRAY_SIZE(dm646x_io_desc),
-	.jtag_id_reg		= 0x01c40028,
-	.ids			= dm646x_ids,
-	.ids_num		= ARRAY_SIZE(dm646x_ids),
-	.pinmux_base		= DAVINCI_SYSTEM_MODULE_BASE,
-	.pinmux_pins		= dm646x_pins,
-	.pinmux_pins_num	= ARRAY_SIZE(dm646x_pins),
-	.emac_pdata		= &dm646x_emac_pdata,
-	.sram_dma		= 0x10010000,
-	.sram_len		= SZ_32K,
-};
-
-void __init dm646x_init_mcasp0(struct snd_platform_data *pdata)
-{
-	dm646x_mcasp0_device.dev.platform_data = pdata;
-	platform_device_register(&dm646x_mcasp0_device);
-}
-
-void __init dm646x_init_mcasp1(struct snd_platform_data *pdata)
-{
-	dm646x_mcasp1_device.dev.platform_data = pdata;
-	platform_device_register(&dm646x_mcasp1_device);
-	platform_device_register(&dm646x_dit_device);
-}
-
-void dm646x_setup_vpif(struct vpif_display_config *display_config,
-		       struct vpif_capture_config *capture_config)
-{
-	unsigned int value;
-
-	value = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));
-	value &= ~VSCLKDIS_MASK;
-	__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VSCLKDIS));
-
-	value = __raw_readl(DAVINCI_SYSMOD_VIRT(SYSMOD_VDD3P3VPWDN));
-	value &= ~VDD3P3V_VID_MASK;
-	__raw_writel(value, DAVINCI_SYSMOD_VIRT(SYSMOD_VDD3P3VPWDN));
-
-	davinci_cfg_reg(DM646X_STSOMUX_DISABLE);
-	davinci_cfg_reg(DM646X_STSIMUX_DISABLE);
-	davinci_cfg_reg(DM646X_PTSOMUX_DISABLE);
-	davinci_cfg_reg(DM646X_PTSIMUX_DISABLE);
-
-	vpif_display_dev.dev.platform_data = display_config;
-	vpif_capture_dev.dev.platform_data = capture_config;
-	platform_device_register(&vpif_dev);
-	platform_device_register(&vpif_display_dev);
-	platform_device_register(&vpif_capture_dev);
-}
-
-int __init dm646x_init_edma(struct edma_rsv_info *rsv)
-{
-	struct platform_device *edma_pdev;
-
-	dm646x_edma_pdata.rsv = rsv;
-
-	edma_pdev = platform_device_register_full(&dm646x_edma_device);
-	return PTR_ERR_OR_ZERO(edma_pdev);
-}
-
-void __init dm646x_init(void)
-{
-	davinci_common_init(&davinci_soc_info_dm646x);
-	davinci_map_sysmod();
-}
-
-void __init dm646x_init_time(unsigned long ref_clk_rate,
-			     unsigned long aux_clkin_rate)
-{
-	void __iomem *pll1, *psc;
-	struct clk *clk;
-	int rv;
-
-	clk_register_fixed_rate(NULL, "ref_clk", NULL, 0, ref_clk_rate);
-	clk_register_fixed_rate(NULL, "aux_clkin", NULL, 0, aux_clkin_rate);
-
-	pll1 = ioremap(DAVINCI_PLL1_BASE, SZ_1K);
-	dm646x_pll1_init(NULL, pll1, NULL);
-
-	psc = ioremap(DAVINCI_PWR_SLEEP_CNTRL_BASE, SZ_4K);
-	dm646x_psc_init(NULL, psc);
-
-	clk = clk_get(NULL, "timer0");
-	if (WARN_ON(IS_ERR(clk))) {
-		pr_err("Unable to get the timer clock\n");
-		return;
-	}
-
-	rv = davinci_timer_register(clk, &dm646x_timer_cfg);
-	WARN(rv, "Unable to register the timer: %d\n", rv);
-}
-
-static struct resource dm646x_pll2_resources[] = {
-	{
-		.start	= DAVINCI_PLL2_BASE,
-		.end	= DAVINCI_PLL2_BASE + SZ_1K - 1,
-		.flags	= IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device dm646x_pll2_device = {
-	.name		= "dm646x-pll2",
-	.id		= -1,
-	.resource	= dm646x_pll2_resources,
-	.num_resources	= ARRAY_SIZE(dm646x_pll2_resources),
-};
-
-void __init dm646x_register_clocks(void)
-{
-	/* PLL1 and PSC are registered in dm646x_init_time() */
-	platform_device_register(&dm646x_pll2_device);
-}
-
-static const struct davinci_aintc_config dm646x_aintc_config = {
-	.reg = {
-		.start		= DAVINCI_ARM_INTC_BASE,
-		.end		= DAVINCI_ARM_INTC_BASE + SZ_4K - 1,
-		.flags		= IORESOURCE_MEM,
-	},
-	.num_irqs		= 64,
-	.prios			= dm646x_default_priorities,
-};
-
-void __init dm646x_init_irq(void)
-{
-	davinci_aintc_init(&dm646x_aintc_config);
-}
-
-static int __init dm646x_init_devices(void)
-{
-	int ret = 0;
-
-	if (!cpu_is_davinci_dm646x())
-		return 0;
-
-	platform_device_register(&dm646x_mdio_device);
-	platform_device_register(&dm646x_emac_device);
-
-	ret = davinci_init_wdt();
-	if (ret)
-		pr_warn("%s: watchdog init failed: %d\n", __func__, ret);
-
-	return ret;
-}
-postcore_initcall(dm646x_init_devices);
-- 
2.36.1

